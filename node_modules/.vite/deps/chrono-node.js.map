{
  "version": 3,
  "sources": ["../../dayjs/plugin/quarterOfYear.js", "../../dayjs/dayjs.min.js", "../../chrono-node/src/locales/en/index.ts", "../../chrono-node/src/results.ts", "../../chrono-node/src/types.ts", "../../chrono-node/src/utils/dayjs.ts", "../../chrono-node/src/timezone.ts", "../../chrono-node/src/utils/pattern.ts", "../../chrono-node/src/calculation/years.ts", "../../chrono-node/src/locales/en/constants.ts", "../../chrono-node/src/common/parsers/AbstractParserWithWordBoundary.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/en/parsers/ENMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/en/parsers/ENMonthNameMiddleEndianParser.ts", "../../chrono-node/src/locales/en/parsers/ENMonthNameParser.ts", "../../chrono-node/src/locales/en/parsers/ENYearMonthDayParser.ts", "../../chrono-node/src/locales/en/parsers/ENSlashMonthFormatParser.ts", "../../chrono-node/src/common/parsers/AbstractTimeExpressionParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeExpressionParser.ts", "../../chrono-node/src/utils/timeunits.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitLaterFormatParser.ts", "../../chrono-node/src/common/abstractRefiners.ts", "../../chrono-node/src/common/refiners/AbstractMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENMergeDateRangeRefiner.ts", "../../chrono-node/src/calculation/mergingCalculation.ts", "../../chrono-node/src/common/refiners/AbstractMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENMergeDateTimeRefiner.ts", "../../chrono-node/src/common/refiners/ExtractTimezoneAbbrRefiner.ts", "../../chrono-node/src/common/refiners/ExtractTimezoneOffsetRefiner.ts", "../../chrono-node/src/common/refiners/OverlapRemovalRefiner.ts", "../../chrono-node/src/common/refiners/ForwardDateRefiner.ts", "../../chrono-node/src/utils/dates.ts", "../../chrono-node/src/common/refiners/UnlikelyFormatFilter.ts", "../../chrono-node/src/common/parsers/ISOFormatParser.ts", "../../chrono-node/src/common/refiners/MergeWeekdayComponentRefiner.ts", "../../chrono-node/src/configurations.ts", "../../chrono-node/src/locales/en/parsers/ENCasualDateParser.ts", "../../chrono-node/src/common/casualReferences.ts", "../../chrono-node/src/locales/en/parsers/ENCasualTimeParser.ts", "../../chrono-node/src/common/calculation/weekdays.ts", "../../chrono-node/src/locales/en/parsers/ENWeekdayParser.ts", "../../chrono-node/src/locales/en/parsers/ENRelativeDateFormatParser.ts", "../../chrono-node/src/common/parsers/SlashDateFormatParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/en/refiners/ENMergeRelativeAfterDateRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENExtractYearSuffixRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENUnlikelyFormatFilter.ts", "../../chrono-node/src/locales/en/configuration.ts", "../../chrono-node/src/chrono.ts", "../../chrono-node/src/locales/de/index.ts", "../../chrono-node/src/locales/de/parsers/DETimeExpressionParser.ts", "../../chrono-node/src/locales/de/constants.ts", "../../chrono-node/src/locales/de/parsers/DEWeekdayParser.ts", "../../chrono-node/src/locales/de/parsers/DESpecificTimeExpressionParser.ts", "../../chrono-node/src/locales/de/refiners/DEMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/de/refiners/DEMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/de/parsers/DECasualDateParser.ts", "../../chrono-node/src/locales/de/parsers/DECasualTimeParser.ts", "../../chrono-node/src/locales/de/parsers/DEMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/de/parsers/DETimeUnitRelativeFormatParser.ts", "../../chrono-node/src/locales/de/parsers/DETimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/fr/index.ts", "../../chrono-node/src/locales/fr/parsers/FRCasualDateParser.ts", "../../chrono-node/src/locales/fr/parsers/FRCasualTimeParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeExpressionParser.ts", "../../chrono-node/src/locales/fr/refiners/FRMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/fr/refiners/FRMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/fr/constants.ts", "../../chrono-node/src/locales/fr/parsers/FRWeekdayParser.ts", "../../chrono-node/src/locales/fr/parsers/FRSpecificTimeExpressionParser.ts", "../../chrono-node/src/locales/fr/parsers/FRMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeUnitRelativeFormatParser.ts", "../../chrono-node/src/locales/ja/index.ts", "../../chrono-node/src/locales/ja/constants.ts", "../../chrono-node/src/locales/ja/parsers/JPStandardParser.ts", "../../chrono-node/src/locales/ja/refiners/JPMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/ja/parsers/JPCasualDateParser.ts", "../../chrono-node/src/locales/pt/index.ts", "../../chrono-node/src/locales/pt/constants.ts", "../../chrono-node/src/locales/pt/parsers/PTWeekdayParser.ts", "../../chrono-node/src/locales/pt/parsers/PTTimeExpressionParser.ts", "../../chrono-node/src/locales/pt/refiners/PTMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/pt/refiners/PTMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/pt/parsers/PTMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/pt/parsers/PTCasualDateParser.ts", "../../chrono-node/src/locales/pt/parsers/PTCasualTimeParser.ts", "../../chrono-node/src/locales/nl/index.ts", "../../chrono-node/src/locales/nl/refiners/NLMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/nl/refiners/NLMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualDateParser.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualTimeParser.ts", "../../chrono-node/src/locales/nl/constants.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLWeekdayParser.ts", "../../chrono-node/src/locales/nl/parsers/NLMonthNameMiddleEndianParser.ts", "../../chrono-node/src/locales/nl/parsers/NLMonthNameParser.ts", "../../chrono-node/src/locales/nl/parsers/NLSlashMonthFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeExpressionParser.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualYearMonthDayParser.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualDateTimeParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLRelativeDateFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitLaterFormatParser.ts", "../../chrono-node/src/locales/zh/index.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansDateParser.ts", "../../chrono-node/src/locales/zh/hans/constants.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansTimeExpressionParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansWeekdayParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantCasualDateParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantDateParser.ts", "../../chrono-node/src/locales/zh/hant/constants.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantTimeExpressionParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantWeekdayParser.ts", "../../chrono-node/src/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/zh/hant/index.ts", "../../chrono-node/src/locales/zh/hans/index.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansCasualDateParser.ts", "../../chrono-node/src/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/ru/index.ts", "../../chrono-node/src/locales/ru/constants.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/ru/parsers/AbstractParserWithWordBoundaryChecking.ts", "../../chrono-node/src/locales/ru/parsers/RUMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/ru/parsers/RUMonthNameParser.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeExpressionParser.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/ru/refiners/RUMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/ru/refiners/RUMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/ru/parsers/RUCasualDateParser.ts", "../../chrono-node/src/locales/ru/parsers/RUCasualTimeParser.ts", "../../chrono-node/src/locales/ru/parsers/RUWeekdayParser.ts", "../../chrono-node/src/locales/ru/parsers/RURelativeDateFormatParser.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/es/index.ts", "../../chrono-node/src/locales/es/constants.ts", "../../chrono-node/src/locales/es/parsers/ESWeekdayParser.ts", "../../chrono-node/src/locales/es/parsers/ESTimeExpressionParser.ts", "../../chrono-node/src/locales/es/refiners/ESMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/es/refiners/ESMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/es/parsers/ESMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/es/parsers/ESCasualDateParser.ts", "../../chrono-node/src/locales/es/parsers/ESCasualTimeParser.ts", "../../chrono-node/src/locales/es/parsers/ESTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/uk/index.ts", "../../chrono-node/src/locales/uk/constants.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/uk/parsers/AbstractParserWithWordBoundaryChecking.ts", "../../chrono-node/src/locales/uk/parsers/UKMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/uk/parsers/UKMonthNameParser.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeExpressionParser.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/uk/refiners/UKMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/uk/refiners/UKMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/uk/parsers/UKCasualDateParser.ts", "../../chrono-node/src/locales/uk/parsers/UKCasualTimeParser.ts", "../../chrono-node/src/locales/uk/parsers/UKWeekdayParser.ts", "../../chrono-node/src/locales/uk/parsers/UKRelativeDateFormatParser.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/index.ts"],
  "sourcesContent": ["!function(t,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_quarterOfYear=n()}(this,(function(){\"use strict\";var t=\"month\",n=\"quarter\";return function(e,i){var r=i.prototype;r.quarter=function(t){return this.$utils().u(t)?Math.ceil((this.month()+1)/3):this.month(this.month()%3+3*(t-1))};var s=r.add;r.add=function(e,i){return e=Number(e),this.$utils().p(i)===n?this.add(3*e,t):s.bind(this)(e,i)};var u=r.startOf;r.startOf=function(e,i){var r=this.$utils(),s=!!r.u(i)||i;if(r.p(e)===n){var o=this.quarter()-1;return s?this.month(3*o).startOf(t).startOf(\"day\"):this.month(3*o+2).endOf(t).endOf(\"day\")}return u.bind(this)(e,i)}}}));", "!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));", "/**\n * Chrono components for English support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { Chrono, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\n\nimport ENDefaultConfiguration from \"./configuration\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\nexport const configuration = new ENDefaultConfiguration();\n\n/**\n * Chrono object configured for parsing *casual* English\n */\nexport const casual = new Chrono(configuration.createCasualConfiguration(false));\n\n/**\n * Chrono object configured for parsing *strict* English\n */\nexport const strict = new Chrono(configuration.createConfiguration(true, false));\n\n/**\n * Chrono object configured for parsing *UK-style* English\n */\nexport const GB = new Chrono(configuration.createCasualConfiguration(true));\n\n/**\n * A shortcut for en.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for en.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n", "import { Component, ParsedComponents, ParsedResult, ParsingReference } from \"./types\";\n\nimport quarterOfYear from \"dayjs/plugin/quarterOfYear\";\nimport dayjs, { QUnitType } from \"dayjs\";\nimport { assignSimilarDate, assignSimilarTime, implySimilarTime } from \"./utils/dayjs\";\nimport { toTimezoneOffset } from \"./timezone\";\ndayjs.extend(quarterOfYear);\n\nexport class ReferenceWithTimezone {\n    readonly instant: Date;\n    readonly timezoneOffset?: number | null;\n\n    constructor(input?: ParsingReference | Date) {\n        input = input ?? new Date();\n        if (input instanceof Date) {\n            this.instant = input;\n            this.timezoneOffset = null;\n        } else {\n            this.instant = input.instant ?? new Date();\n            this.timezoneOffset = toTimezoneOffset(input.timezone, this.instant);\n        }\n    }\n\n    /**\n     * Returns a JS date (system timezone) with the { year, month, day, hour, minute, second } equal to the reference.\n     * The output's instant is NOT the reference's instant when the reference's and system's timezone are different.\n     */\n    getDateWithAdjustedTimezone() {\n        const date = new Date(this.instant);\n        if (this.timezoneOffset !== null) {\n            date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));\n        }\n        return date;\n    }\n\n    /**\n     * Returns the number minutes difference between the JS date's timezone and the reference timezone.\n     * @param date\n     * @param overrideTimezoneOffset\n     */\n    getSystemTimezoneAdjustmentMinute(date?: Date, overrideTimezoneOffset?: number): number {\n        if (!date || date.getTime() < 0) {\n            // Javascript date timezone calculation got effect when the time epoch < 0\n            // e.g. new Date('Tue Feb 02 1300 00:00:00 GMT+0900 (JST)') => Tue Feb 02 1300 00:18:59 GMT+0918 (JST)\n            date = new Date();\n        }\n\n        const currentTimezoneOffset = -date.getTimezoneOffset();\n        const targetTimezoneOffset = overrideTimezoneOffset ?? this.timezoneOffset ?? currentTimezoneOffset;\n        return currentTimezoneOffset - targetTimezoneOffset;\n    }\n\n    getTimezoneOffset(): number {\n        return this.timezoneOffset ?? -this.instant.getTimezoneOffset();\n    }\n}\n\nexport class ParsingComponents implements ParsedComponents {\n    private knownValues: { [c in Component]?: number };\n    private impliedValues: { [c in Component]?: number };\n    private reference: ReferenceWithTimezone;\n    private _tags = new Set<string>();\n\n    constructor(reference: ReferenceWithTimezone, knownComponents?: { [c in Component]?: number }) {\n        this.reference = reference;\n        this.knownValues = {};\n        this.impliedValues = {};\n        if (knownComponents) {\n            for (const key in knownComponents) {\n                this.knownValues[key as Component] = knownComponents[key as Component];\n            }\n        }\n\n        const refDayJs = reference.getDateWithAdjustedTimezone();\n        this.imply(\"day\", refDayJs.getDate());\n        this.imply(\"month\", refDayJs.getMonth() + 1);\n        this.imply(\"year\", refDayJs.getFullYear());\n        this.imply(\"hour\", 12);\n        this.imply(\"minute\", 0);\n        this.imply(\"second\", 0);\n        this.imply(\"millisecond\", 0);\n    }\n\n    get(component: Component): number | null {\n        if (component in this.knownValues) {\n            return this.knownValues[component];\n        }\n\n        if (component in this.impliedValues) {\n            return this.impliedValues[component];\n        }\n\n        return null;\n    }\n\n    isCertain(component: Component): boolean {\n        return component in this.knownValues;\n    }\n\n    getCertainComponents(): Array<Component> {\n        return Object.keys(this.knownValues) as Array<Component>;\n    }\n\n    imply(component: Component, value: number): ParsingComponents {\n        if (component in this.knownValues) {\n            return this;\n        }\n        this.impliedValues[component] = value;\n        return this;\n    }\n\n    assign(component: Component, value: number): ParsingComponents {\n        this.knownValues[component] = value;\n        delete this.impliedValues[component];\n        return this;\n    }\n\n    delete(component: Component) {\n        delete this.knownValues[component];\n        delete this.impliedValues[component];\n    }\n\n    clone(): ParsingComponents {\n        const component = new ParsingComponents(this.reference);\n        component.knownValues = {};\n        component.impliedValues = {};\n\n        for (const key in this.knownValues) {\n            component.knownValues[key as Component] = this.knownValues[key as Component];\n        }\n\n        for (const key in this.impliedValues) {\n            component.impliedValues[key as Component] = this.impliedValues[key as Component];\n        }\n\n        return component;\n    }\n\n    isOnlyDate(): boolean {\n        return !this.isCertain(\"hour\") && !this.isCertain(\"minute\") && !this.isCertain(\"second\");\n    }\n\n    isOnlyTime(): boolean {\n        return (\n            !this.isCertain(\"weekday\") && !this.isCertain(\"day\") && !this.isCertain(\"month\") && !this.isCertain(\"year\")\n        );\n    }\n\n    isOnlyWeekdayComponent(): boolean {\n        return this.isCertain(\"weekday\") && !this.isCertain(\"day\") && !this.isCertain(\"month\");\n    }\n\n    isDateWithUnknownYear(): boolean {\n        return this.isCertain(\"month\") && !this.isCertain(\"year\");\n    }\n\n    isValidDate(): boolean {\n        const date = this.dateWithoutTimezoneAdjustment();\n\n        if (date.getFullYear() !== this.get(\"year\")) return false;\n        if (date.getMonth() !== this.get(\"month\") - 1) return false;\n        if (date.getDate() !== this.get(\"day\")) return false;\n        if (this.get(\"hour\") != null && date.getHours() != this.get(\"hour\")) return false;\n        if (this.get(\"minute\") != null && date.getMinutes() != this.get(\"minute\")) return false;\n\n        return true;\n    }\n\n    toString() {\n        return `[ParsingComponents {\n            tags: ${JSON.stringify(Array.from(this._tags).sort())}, \n            knownValues: ${JSON.stringify(this.knownValues)}, \n            impliedValues: ${JSON.stringify(this.impliedValues)}}, \n            reference: ${JSON.stringify(this.reference)}]`;\n    }\n\n    dayjs() {\n        return dayjs(this.dateWithoutTimezoneAdjustment());\n    }\n\n    date(): Date {\n        const date = this.dateWithoutTimezoneAdjustment();\n        const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get(\"timezoneOffset\"));\n        return new Date(date.getTime() + timezoneAdjustment * 60000);\n    }\n\n    addTag(tag: string): ParsingComponents {\n        this._tags.add(tag);\n        return this;\n    }\n\n    addTags(tags: string[] | Set<string>): ParsingComponents {\n        for (const tag of tags) {\n            this._tags.add(tag);\n        }\n        return this;\n    }\n\n    tags(): Set<string> {\n        return new Set(this._tags);\n    }\n\n    private dateWithoutTimezoneAdjustment() {\n        const date = new Date(\n            this.get(\"year\"),\n            this.get(\"month\") - 1,\n            this.get(\"day\"),\n            this.get(\"hour\"),\n            this.get(\"minute\"),\n            this.get(\"second\"),\n            this.get(\"millisecond\")\n        );\n\n        date.setFullYear(this.get(\"year\"));\n        return date;\n    }\n\n    static createRelativeFromReference(\n        reference: ReferenceWithTimezone,\n        fragments: { [c in QUnitType]?: number }\n    ): ParsingComponents {\n        let date = dayjs(reference.getDateWithAdjustedTimezone());\n        for (const key in fragments) {\n            date = date.add(fragments[key as QUnitType], key as QUnitType);\n        }\n\n        const components = new ParsingComponents(reference);\n        components.addTag(\"result/relativeDate\");\n        if (fragments[\"hour\"] || fragments[\"minute\"] || fragments[\"second\"]) {\n            components.addTag(\"result/relativeDateAndTime\");\n            assignSimilarTime(components, date);\n            assignSimilarDate(components, date);\n            components.assign(\"timezoneOffset\", reference.getTimezoneOffset());\n        } else {\n            implySimilarTime(components, date);\n            components.imply(\"timezoneOffset\", reference.getTimezoneOffset());\n\n            if (fragments[\"d\"]) {\n                components.assign(\"day\", date.date());\n                components.assign(\"month\", date.month() + 1);\n                components.assign(\"year\", date.year());\n            } else if (fragments[\"week\"]) {\n                components.assign(\"day\", date.date());\n                components.assign(\"month\", date.month() + 1);\n                components.assign(\"year\", date.year());\n                components.imply(\"weekday\", date.day());\n            } else {\n                components.imply(\"day\", date.date());\n                if (fragments[\"month\"]) {\n                    components.assign(\"month\", date.month() + 1);\n                    components.assign(\"year\", date.year());\n                } else {\n                    components.imply(\"month\", date.month() + 1);\n                    if (fragments[\"year\"]) {\n                        components.assign(\"year\", date.year());\n                    } else {\n                        components.imply(\"year\", date.year());\n                    }\n                }\n            }\n        }\n\n        return components;\n    }\n}\n\nexport class ParsingResult implements ParsedResult {\n    refDate: Date;\n    index: number;\n    text: string;\n\n    reference: ReferenceWithTimezone;\n\n    start: ParsingComponents;\n    end?: ParsingComponents;\n\n    constructor(\n        reference: ReferenceWithTimezone,\n        index: number,\n        text: string,\n        start?: ParsingComponents,\n        end?: ParsingComponents\n    ) {\n        this.reference = reference;\n        this.refDate = reference.instant;\n        this.index = index;\n        this.text = text;\n        this.start = start || new ParsingComponents(reference);\n        this.end = end;\n    }\n\n    clone() {\n        const result = new ParsingResult(this.reference, this.index, this.text);\n        result.start = this.start ? this.start.clone() : null;\n        result.end = this.end ? this.end.clone() : null;\n        return result;\n    }\n\n    date(): Date {\n        return this.start.date();\n    }\n\n    addTag(tag: string): ParsingResult {\n        this.start.addTag(tag);\n        if (this.end) {\n            this.end.addTag(tag);\n        }\n        return this;\n    }\n\n    addTags(tags: string[] | Set<string>): ParsingResult {\n        this.start.addTags(tags);\n        if (this.end) {\n            this.end.addTags(tags);\n        }\n        return this;\n    }\n\n    tags(): Set<string> {\n        const combinedTags: Set<string> = new Set(this.start.tags());\n        if (this.end) {\n            for (const tag of this.end.tags()) {\n                combinedTags.add(tag);\n            }\n        }\n        return combinedTags;\n    }\n\n    toString() {\n        const tags = Array.from(this.tags()).sort();\n        return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;\n    }\n}\n", "import { DebugConsume, DebugHandler } from \"./debugging\";\n\nexport interface ParsingOption {\n    /**\n     * To parse only forward dates (the results should be after the reference date).\n     * This effects date/time implication (e.g. weekday or time mentioning)\n     */\n    forwardDate?: boolean;\n\n    /**\n     * Additional timezone keywords for the parsers to recognize.\n     * Any value provided will override the default handling of that value.\n     */\n    timezones?: TimezoneAbbrMap;\n\n    /**\n     * Internal debug event handler.\n     * @internal\n     */\n    debug?: DebugHandler | DebugConsume;\n}\n\n/**\n * Some timezone abbreviations are ambiguous in that they refer to different offsets\n * depending on the time of year — daylight savings time (DST), or non-DST. This interface\n * allows defining such timezones\n */\nexport interface AmbiguousTimezoneMap {\n    timezoneOffsetDuringDst: number;\n    timezoneOffsetNonDst: number;\n    /**\n     * Return the start date of DST for the given year.\n     * timezone.ts contains helper methods for common such rules.\n     */\n    dstStart: (year: number) => Date;\n    /**\n     * Return the end date of DST for the given year.\n     * timezone.ts contains helper methods for common such rules.\n     */\n    dstEnd: (year: number) => Date;\n}\n\n/**\n * A map describing how timezone abbreviations should map to time offsets.\n * Supports both unambigous mappings abbreviation => offset,\n * and ambiguous mappings, where the offset will depend on whether the\n * time in question is during daylight savings time or not.\n */\nexport type TimezoneAbbrMap = { [key: string]: number | AmbiguousTimezoneMap };\n\nexport interface ParsingReference {\n    /**\n     * Reference date. The instant (JavaScript Date object) when the input is written or mention.\n     * This effect date/time implication (e.g. weekday or time mentioning).\n     * (default = now)\n     */\n    instant?: Date;\n\n    /**\n     * Reference timezone. The timezone where the input is written or mention.\n     * Date/time implication will account the difference between input timezone and the current system timezone.\n     * (default = current timezone)\n     */\n    timezone?: string | number;\n}\n\n/**\n * Parsed result or final output.\n * Each result object represents a date/time (or date/time-range) mentioning in the input.\n */\nexport interface ParsedResult {\n    readonly refDate: Date;\n    readonly index: number;\n    readonly text: string;\n\n    readonly start: ParsedComponents;\n    readonly end?: ParsedComponents;\n\n    /**\n     * @return a javascript date object created from the `result.start`.\n     */\n    date(): Date;\n\n    /**\n     * @return debugging tags combined of the `result.start` and `result.end`.\n     */\n    tags(): Set<string>;\n}\n\n/**\n * A collection of parsed date/time components (e.g. day, hour, minute, ..., etc).\n *\n * Each parsed component has three different levels of certainty.\n * - *Certain* (or *Known*): The component is directly mentioned and parsed.\n * - *Implied*: The component is not directly mentioned, but implied by other parsed information.\n * - *Unknown*: Completely no mention of the component.\n */\nexport interface ParsedComponents {\n    /**\n     * Check the component certainly if the component is *Certain* (or *Known*)\n     */\n    isCertain(component: Component): boolean;\n\n    /**\n     * Get the component value for either *Certain* or *Implied* value.\n     */\n    get(component: Component): number | null;\n\n    /**\n     * @return a javascript date object.\n     */\n    date(): Date;\n\n    /**\n     * @return debugging tags of the parsed component.\n     */\n    tags(): Set<string>;\n}\n\nexport type Component =\n    | \"year\"\n    | \"month\"\n    | \"day\"\n    | \"weekday\"\n    | \"hour\"\n    | \"minute\"\n    | \"second\"\n    | \"millisecond\"\n    | \"meridiem\"\n    | \"timezoneOffset\";\n\nexport enum Meridiem {\n    AM = 0,\n    PM = 1,\n}\n\nexport enum Weekday {\n    SUNDAY = 0,\n    MONDAY = 1,\n    TUESDAY = 2,\n    WEDNESDAY = 3,\n    THURSDAY = 4,\n    FRIDAY = 5,\n    SATURDAY = 6,\n}\n\nexport enum Month {\n    JANUARY = 1,\n    FEBRUARY = 2,\n    MARCH = 3,\n    APRIL = 4,\n    MAY = 5,\n    JUNE = 6,\n    JULY = 7,\n    AUGUST = 8,\n    SEPTEMBER = 9,\n    OCTOBER = 10,\n    NOVEMBER = 11,\n    DECEMBER = 12,\n}\n", "import { ParsingComponents } from \"../results\";\nimport dayjs from \"dayjs\";\nimport { Meridiem } from \"../types\";\n\nexport function assignTheNextDay(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    targetDayJs = targetDayJs.add(1, \"day\");\n    assignSimilarDate(component, targetDayJs);\n    implySimilarTime(component, targetDayJs);\n}\n\nexport function implyTheNextDay(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    targetDayJs = targetDayJs.add(1, \"day\");\n    implySimilarDate(component, targetDayJs);\n    implySimilarTime(component, targetDayJs);\n}\n\nexport function assignSimilarDate(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.assign(\"day\", targetDayJs.date());\n    component.assign(\"month\", targetDayJs.month() + 1);\n    component.assign(\"year\", targetDayJs.year());\n}\n\nexport function assignSimilarTime(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.assign(\"hour\", targetDayJs.hour());\n    component.assign(\"minute\", targetDayJs.minute());\n    component.assign(\"second\", targetDayJs.second());\n    component.assign(\"millisecond\", targetDayJs.millisecond());\n    if (component.get(\"hour\") < 12) {\n        component.assign(\"meridiem\", Meridiem.AM);\n    } else {\n        component.assign(\"meridiem\", Meridiem.PM);\n    }\n}\n\n/**\n * @deprecated Use `dates.implySimilarDate` with normal Javascript Date instead.\n */\nexport function implySimilarDate(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.imply(\"day\", targetDayJs.date());\n    component.imply(\"month\", targetDayJs.month() + 1);\n    component.imply(\"year\", targetDayJs.year());\n}\n\n/**\n * @deprecated Use `dates.implySimilarTime` with normal Javascript Date instead.\n */\nexport function implySimilarTime(component: ParsingComponents, targetDayJs: dayjs.Dayjs) {\n    component.imply(\"hour\", targetDayJs.hour());\n    component.imply(\"minute\", targetDayJs.minute());\n    component.imply(\"second\", targetDayJs.second());\n    component.imply(\"millisecond\", targetDayJs.millisecond());\n}\n", "import dayjs from \"dayjs\";\nimport { TimezoneAbbrMap, Weekday, Month } from \"./types\";\n\nexport const TIMEZONE_ABBR_MAP: TimezoneAbbrMap = {\n    ACDT: 630,\n    ACST: 570,\n    ADT: -180,\n    AEDT: 660,\n    AEST: 600,\n    AFT: 270,\n    AKDT: -480,\n    AKST: -540,\n    ALMT: 360,\n    AMST: -180,\n    AMT: -240,\n    ANAST: 720,\n    ANAT: 720,\n    AQTT: 300,\n    ART: -180,\n    AST: -240,\n    AWDT: 540,\n    AWST: 480,\n    AZOST: 0,\n    AZOT: -60,\n    AZST: 300,\n    AZT: 240,\n    BNT: 480,\n    BOT: -240,\n    BRST: -120,\n    BRT: -180,\n    BST: 60,\n    BTT: 360,\n    CAST: 480,\n    CAT: 120,\n    CCT: 390,\n    CDT: -300,\n    CEST: 120,\n    // Note: Many sources define CET as a constant UTC+1. In common usage, however,\n    // CET usually refers to the time observed in most of Europe, be it standard time or daylight saving time.\n    CET: {\n        timezoneOffsetDuringDst: 2 * 60,\n        timezoneOffsetNonDst: 60,\n        dstStart: (year: number) => getLastWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2),\n        dstEnd: (year: number) => getLastWeekdayOfMonth(year, Month.OCTOBER, Weekday.SUNDAY, 3),\n    },\n    CHADT: 825,\n    CHAST: 765,\n    CKT: -600,\n    CLST: -180,\n    CLT: -240,\n    COT: -300,\n    CST: -360,\n    CT: {\n        timezoneOffsetDuringDst: -5 * 60,\n        timezoneOffsetNonDst: -6 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    CVT: -60,\n    CXT: 420,\n    ChST: 600,\n    DAVT: 420,\n    EASST: -300,\n    EAST: -360,\n    EAT: 180,\n    ECT: -300,\n    EDT: -240,\n    EEST: 180,\n    EET: 120,\n    EGST: 0,\n    EGT: -60,\n    EST: -300,\n    ET: {\n        timezoneOffsetDuringDst: -4 * 60,\n        timezoneOffsetNonDst: -5 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    FJST: 780,\n    FJT: 720,\n    FKST: -180,\n    FKT: -240,\n    FNT: -120,\n    GALT: -360,\n    GAMT: -540,\n    GET: 240,\n    GFT: -180,\n    GILT: 720,\n    GMT: 0,\n    GST: 240,\n    GYT: -240,\n    HAA: -180,\n    HAC: -300,\n    HADT: -540,\n    HAE: -240,\n    HAP: -420,\n    HAR: -360,\n    HAST: -600,\n    HAT: -90,\n    HAY: -480,\n    HKT: 480,\n    HLV: -210,\n    HNA: -240,\n    HNC: -360,\n    HNE: -300,\n    HNP: -480,\n    HNR: -420,\n    HNT: -150,\n    HNY: -540,\n    HOVT: 420,\n    ICT: 420,\n    IDT: 180,\n    IOT: 360,\n    IRDT: 270,\n    IRKST: 540,\n    IRKT: 540,\n    IRST: 210,\n    IST: 330,\n    JST: 540,\n    KGT: 360,\n    KRAST: 480,\n    KRAT: 480,\n    KST: 540,\n    KUYT: 240,\n    LHDT: 660,\n    LHST: 630,\n    LINT: 840,\n    MAGST: 720,\n    MAGT: 720,\n    MART: -510,\n    MAWT: 300,\n    MDT: -360,\n    MESZ: 120,\n    MEZ: 60,\n    MHT: 720,\n    MMT: 390,\n    MSD: 240,\n    MSK: 180,\n    MST: -420,\n    MT: {\n        timezoneOffsetDuringDst: -6 * 60,\n        timezoneOffsetNonDst: -7 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    MUT: 240,\n    MVT: 300,\n    MYT: 480,\n    NCT: 660,\n    NDT: -90,\n    NFT: 690,\n    NOVST: 420,\n    NOVT: 360,\n    NPT: 345,\n    NST: -150,\n    NUT: -660,\n    NZDT: 780,\n    NZST: 720,\n    OMSST: 420,\n    OMST: 420,\n    PDT: -420,\n    PET: -300,\n    PETST: 720,\n    PETT: 720,\n    PGT: 600,\n    PHOT: 780,\n    PHT: 480,\n    PKT: 300,\n    PMDT: -120,\n    PMST: -180,\n    PONT: 660,\n    PST: -480,\n    PT: {\n        timezoneOffsetDuringDst: -7 * 60,\n        timezoneOffsetNonDst: -8 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    PWT: 540,\n    PYST: -180,\n    PYT: -240,\n    RET: 240,\n    SAMT: 240,\n    SAST: 120,\n    SBT: 660,\n    SCT: 240,\n    SGT: 480,\n    SRT: -180,\n    SST: -660,\n    TAHT: -600,\n    TFT: 300,\n    TJT: 300,\n    TKT: 780,\n    TLT: 540,\n    TMT: 300,\n    TVT: 720,\n    ULAT: 480,\n    UTC: 0,\n    UYST: -120,\n    UYT: -180,\n    UZT: 300,\n    VET: -210,\n    VLAST: 660,\n    VLAT: 660,\n    VUT: 660,\n    WAST: 120,\n    WAT: 60,\n    WEST: 60,\n    WESZ: 60,\n    WET: 0,\n    WEZ: 0,\n    WFT: 720,\n    WGST: -120,\n    WGT: -180,\n    WIB: 420,\n    WIT: 540,\n    WITA: 480,\n    WST: 780,\n    WT: 0,\n    YAKST: 600,\n    YAKT: 600,\n    YAPT: 600,\n    YEKST: 360,\n    YEKT: 360,\n};\n\n/**\n * Get the date which is the nth occurence of a given weekday in a given month and year.\n *\n * @param year The year for which to find the date\n * @param month The month in which the date occurs\n * @param weekday The weekday on which the date occurs\n * @param n The nth occurence of the given weekday on the month to return\n * @param hour The hour of day which should be set on the returned date\n * @return The date which is the nth occurence of a given weekday in a given\n *         month and year, at the given hour of day\n */\nexport function getNthWeekdayOfMonth(year: number, month: Month, weekday: Weekday, n: 1 | 2 | 3 | 4, hour = 0): Date {\n    let dayOfMonth = 0;\n    let i = 0;\n    while (i < n) {\n        dayOfMonth++;\n        const date = new Date(year, month - 1, dayOfMonth);\n        if (date.getDay() === weekday) i++;\n    }\n    return new Date(year, month - 1, dayOfMonth, hour);\n}\n\n/**\n * Get the date which is the last occurence of a given weekday in a given month and year.\n *\n * @param year The year for which to find the date\n * @param month The month in which the date occurs\n * @param weekday The weekday on which the date occurs\n * @param hour The hour of day which should be set on the returned date\n * @return The date which is the last occurence of a given weekday in a given\n *         month and year, at the given hour of day\n */\nexport function getLastWeekdayOfMonth(year: number, month: Month, weekday: Weekday, hour = 0): Date {\n    // Procedure: Find the first weekday of the next month, compare with the given weekday,\n    // and use the difference to determine how many days to subtract from the first of the next month.\n    const oneIndexedWeekday = weekday === 0 ? 7 : weekday;\n    const date = new Date(year, month - 1 + 1, 1, 12);\n    const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();\n    let dayDiff;\n    if (firstWeekdayNextMonth === oneIndexedWeekday) dayDiff = 7;\n    else if (firstWeekdayNextMonth < oneIndexedWeekday) dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;\n    else dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;\n    date.setDate(date.getDate() - dayDiff);\n    return new Date(year, month - 1, date.getDate(), hour);\n}\n\n/**\n * Finds and returns timezone offset. If timezoneInput is numeric, it is returned. Otherwise, look for timezone offsets\n * in the following order: timezoneOverrides -> {@link TIMEZONE_ABBR_MAP}.\n *\n * @param timezoneInput Uppercase timezone abbreviation or numeric offset in minutes\n * @param date The date to use to determine whether to return DST offsets for ambiguous timezones\n * @param timezoneOverrides Overrides for timezones\n * @return timezone offset in minutes\n */\nexport function toTimezoneOffset(\n    timezoneInput?: string | number,\n    date?: Date,\n    timezoneOverrides: TimezoneAbbrMap = {}\n): number | null {\n    if (timezoneInput == null) {\n        return null;\n    }\n\n    if (typeof timezoneInput === \"number\") {\n        return timezoneInput;\n    }\n\n    const matchedTimezone = timezoneOverrides[timezoneInput] ?? TIMEZONE_ABBR_MAP[timezoneInput];\n    if (matchedTimezone == null) {\n        return null;\n    }\n    // This means that we have matched an unambiguous timezone\n    if (typeof matchedTimezone == \"number\") {\n        return matchedTimezone;\n    }\n\n    // The matched timezone is an ambiguous timezone, where the offset depends on whether the context (refDate)\n    // is during daylight savings or not.\n\n    // Without refDate as context, there's no way to know if DST or non-DST offset should be used. Return null instead.\n    if (date == null) {\n        return null;\n    }\n\n    // Return DST offset if the refDate is during daylight savings\n    if (\n        dayjs(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) &&\n        !dayjs(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))\n    ) {\n        return matchedTimezone.timezoneOffsetDuringDst;\n    }\n\n    // refDate is not during DST => return non-DST offset\n    return matchedTimezone.timezoneOffsetNonDst;\n}\n", "type DictionaryLike = string[] | { [word: string]: unknown } | Map<string, unknown>;\n\nexport function repeatedTimeunitPattern(\n    prefix: string,\n    singleTimeunitPattern: string,\n    connectorPattern = \"\\\\s{0,5},?\\\\s{0,5}\"\n): string {\n    const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\\((?!\\?)/g, \"(?:\");\n    return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;\n}\n\nexport function extractTerms(dictionary: DictionaryLike): string[] {\n    let keys: string[];\n    if (dictionary instanceof Array) {\n        keys = [...dictionary];\n    } else if (dictionary instanceof Map) {\n        keys = Array.from((dictionary as Map<string, unknown>).keys());\n    } else {\n        keys = Object.keys(dictionary);\n    }\n\n    return keys;\n}\n\nexport function matchAnyPattern(dictionary: DictionaryLike): string {\n    // TODO: More efficient regex pattern by considering duplicated prefix\n\n    const joinedTerms = extractTerms(dictionary)\n        .sort((a, b) => b.length - a.length)\n        .join(\"|\")\n        .replace(/\\./g, \"\\\\.\");\n\n    return `(?:${joinedTerms})`;\n}\n", "import dayjs from \"dayjs\";\n\n/**\n * Find the most likely year, from a raw number. For example:\n * 1997 => 1997\n * 97 => 1997\n * 12 => 2012\n */\nexport function findMostLikelyADYear(yearNumber: number): number {\n    if (yearNumber < 100) {\n        if (yearNumber > 50) {\n            yearNumber = yearNumber + 1900;\n        } else {\n            yearNumber = yearNumber + 2000;\n        }\n    }\n\n    return yearNumber;\n}\n\nexport function findYearClosestToRef(refDate: Date, day: number, month: number): number {\n    //Find the most appropriated year\n    const refMoment = dayjs(refDate);\n    let dateMoment = refMoment;\n    dateMoment = dateMoment.month(month - 1);\n    dateMoment = dateMoment.date(day);\n    dateMoment = dateMoment.year(refMoment.year());\n\n    const nextYear = dateMoment.add(1, \"y\");\n    const lastYear = dateMoment.add(-1, \"y\");\n    if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {\n        dateMoment = nextYear;\n    } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {\n        dateMoment = lastYear;\n    }\n\n    return dateMoment.year();\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { TimeUnits } from \"../../utils/timeunits\";\nimport { Weekday } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: Weekday } = {\n    sunday: 0,\n    sun: 0,\n    \"sun.\": 0,\n    monday: 1,\n    mon: 1,\n    \"mon.\": 1,\n    tuesday: 2,\n    tue: 2,\n    \"tue.\": 2,\n    wednesday: 3,\n    wed: 3,\n    \"wed.\": 3,\n    thursday: 4,\n    thurs: 4,\n    \"thurs.\": 4,\n    thur: 4,\n    \"thur.\": 4,\n    thu: 4,\n    \"thu.\": 4,\n    friday: 5,\n    fri: 5,\n    \"fri.\": 5,\n    saturday: 6,\n    sat: 6,\n    \"sat.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    january: 1,\n    february: 2,\n    march: 3,\n    april: 4,\n    may: 5,\n    june: 6,\n    july: 7,\n    august: 8,\n    september: 9,\n    october: 10,\n    november: 11,\n    december: 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    jan: 1,\n    \"jan.\": 1,\n    feb: 2,\n    \"feb.\": 2,\n    mar: 3,\n    \"mar.\": 3,\n    apr: 4,\n    \"apr.\": 4,\n    jun: 6,\n    \"jun.\": 6,\n    jul: 7,\n    \"jul.\": 7,\n    aug: 8,\n    \"aug.\": 8,\n    sep: 9,\n    \"sep.\": 9,\n    sept: 9,\n    \"sept.\": 9,\n    oct: 10,\n    \"oct.\": 10,\n    nov: 11,\n    \"nov.\": 11,\n    dec: 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9,\n    ten: 10,\n    eleven: 11,\n    twelve: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    first: 1,\n    second: 2,\n    third: 3,\n    fourth: 4,\n    fifth: 5,\n    sixth: 6,\n    seventh: 7,\n    eighth: 8,\n    ninth: 9,\n    tenth: 10,\n    eleventh: 11,\n    twelfth: 12,\n    thirteenth: 13,\n    fourteenth: 14,\n    fifteenth: 15,\n    sixteenth: 16,\n    seventeenth: 17,\n    eighteenth: 18,\n    nineteenth: 19,\n    twentieth: 20,\n    \"twenty first\": 21,\n    \"twenty-first\": 21,\n    \"twenty second\": 22,\n    \"twenty-second\": 22,\n    \"twenty third\": 23,\n    \"twenty-third\": 23,\n    \"twenty fourth\": 24,\n    \"twenty-fourth\": 24,\n    \"twenty fifth\": 25,\n    \"twenty-fifth\": 25,\n    \"twenty sixth\": 26,\n    \"twenty-sixth\": 26,\n    \"twenty seventh\": 27,\n    \"twenty-seventh\": 27,\n    \"twenty eighth\": 28,\n    \"twenty-eighth\": 28,\n    \"twenty ninth\": 29,\n    \"twenty-ninth\": 29,\n    \"thirtieth\": 30,\n    \"thirty first\": 31,\n    \"thirty-first\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY_NO_ABBR: { [word: string]: OpUnitType | QUnitType } = {\n    second: \"second\",\n    seconds: \"second\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    hour: \"hour\",\n    hours: \"hour\",\n    day: \"d\",\n    days: \"d\",\n    week: \"week\",\n    weeks: \"week\",\n    month: \"month\",\n    months: \"month\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    year: \"year\",\n    years: \"year\",\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    s: \"second\",\n    sec: \"second\",\n    second: \"second\",\n    seconds: \"second\",\n    m: \"minute\",\n    min: \"minute\",\n    mins: \"minute\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    h: \"hour\",\n    hr: \"hour\",\n    hrs: \"hour\",\n    hour: \"hour\",\n    hours: \"hour\",\n    d: \"d\",\n    day: \"d\",\n    days: \"d\",\n    w: \"w\",\n    week: \"week\",\n    weeks: \"week\",\n    mo: \"month\",\n    mon: \"month\",\n    mos: \"month\",\n    month: \"month\",\n    months: \"month\",\n    qtr: \"quarter\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    y: \"year\",\n    yr: \"year\",\n    year: \"year\",\n    years: \"year\",\n    // Also, merge the entries from the full-name dictionary.\n    // We leave the duplicated entries for readability.\n    ...TIME_UNIT_DICTIONARY_NO_ABBR,\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|half(?:\\\\s{0,2}an?)?|an?\\\\b(?:\\\\s{0,2}few)?|few|several|the|a?\\\\s{0,2}couple\\\\s{0,2}(?:of)?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"a\" || num === \"an\" || num == \"the\") {\n        return 1;\n    } else if (num.match(/few/)) {\n        return 3;\n    } else if (num.match(/half/)) {\n        return 0.5;\n    } else if (num.match(/couple/)) {\n        return 2;\n    } else if (num.match(/several/)) {\n        return 7;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n\n    num = num.replace(/(?:st|nd|rd|th)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;\nexport function parseYear(match: string): number {\n    if (/BE/i.test(match)) {\n        // Buddhist Era\n        match = match.replace(/BE/i, \"\");\n        return parseInt(match) - 543;\n    }\n\n    if (/BCE?/i.test(match)) {\n        // Before Christ, Before Common Era\n        match = match.replace(/BCE?/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(AD|CE)/i.test(match)) {\n        // Anno Domini, Common Era\n        match = match.replace(/(AD|CE)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nconst SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(\n    TIME_UNIT_DICTIONARY_NO_ABBR\n)})`;\n\nconst TIME_UNIT_CONNECTOR_PATTERN = `\\\\s{0,5},?(?:\\\\s*and)?\\\\s{0,5}`;\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:about|around)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_PATTERN,\n    TIME_UNIT_CONNECTOR_PATTERN\n);\nexport const TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:about|around)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_NO_ABBR_PATTERN,\n    TIME_UNIT_CONNECTOR_PATTERN\n);\n\nexport function parseTimeUnits(timeunitText): null | TimeUnits {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    if (Object.keys(fragments).length == 0) {\n        return null;\n    }\n    return fragments;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    if (match[0].match(/^[a-zA-Z]+$/)) {\n        return;\n    }\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Component } from \"../../types\";\n\n/**\n * A parser that checks for word boundary and applying the inner pattern and extraction.\n */\nexport abstract class AbstractParserWithWordBoundaryChecking implements Parser {\n    abstract innerPattern(context: ParsingContext): RegExp;\n    abstract innerExtract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n\n    // Overrides this method if there is more efficient way to check for inner pattern change.\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return this.innerPattern(context) !== currentInnerPattern;\n    }\n\n    patternLeftBoundary(): string {\n        return `(\\\\W|^)`;\n    }\n\n    private cachedInnerPattern?: RegExp = null;\n    private cachedPattern?: RegExp = null;\n\n    pattern(context: ParsingContext): RegExp {\n        if (this.cachedInnerPattern) {\n            if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {\n                return this.cachedPattern;\n            }\n        }\n        this.cachedInnerPattern = this.innerPattern(context);\n        this.cachedPattern = new RegExp(\n            `${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`,\n            this.cachedInnerPattern.flags\n        );\n        return this.cachedPattern;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const header = match[1] ?? \"\";\n        match.index = match.index + header.length;\n        match[0] = match[0].substring(header.length);\n        for (let i = 2; i < match.length; i++) {\n            match[i - 1] = match[i];\n        }\n\n        return this.innerExtract(context, match);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(\n    `(?:(?:within|in|for)\\\\s*)?` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITH_PREFIX = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITH_PREFIX_STRICT = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        if (this.strictMode) {\n            return PATTERN_WITH_PREFIX_STRICT;\n        }\n        return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // Exclude \"for the unit\" phases, e.g. \"for the year\"\n        if (match[0].match(/^for\\s*the\\s*\\w+/)) {\n            return null;\n        }\n        const timeUnits = parseTimeUnits(match[1]);\n        if (!timeUnits) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(?:on\\\\s{0,3})?` +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:` +\n            `\\\\s{0,3}(?:to|\\\\-|\\\\–|until|through|till)?\\\\s{0,3}` +\n            `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        `(?:-|/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:\" +\n            `(?:-|/|,?\\\\s{0,3})` +\n            `(${YEAR_PATTERN}(?!\\\\w))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ENMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` +\n        \"(?:\" +\n            \"(?:to|\\\\-)\\\\s*\" +\n            `(${ORDINAL_NUMBER_PATTERN})\\\\s*` +\n        \")?\" +\n        \"(?:\" +\n            `(?:-|/|\\\\s*,\\\\s*|\\\\s+)` +\n            `(${YEAR_PATTERN})` +\n        \")?\" +\n        \"(?=\\\\W|$)(?!\\\\:\\\\d)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing US's date format that begin with month's name.\n *  - January 13\n *  - January 13, 2012\n *  - January 13 - 15, 2012\n * Note: Watch out for:\n *  - January 12:00\n *  - January 12.44\n *  - January 1222344\n *  - January 21 (when shouldSkipYearLikeDate=true)\n */\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    shouldSkipYearLikeDate: boolean;\n\n    constructor(shouldSkipYearLikeDate: boolean) {\n        super();\n        this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            return null;\n        }\n\n        // Skip the case where the day looks like a year (ex: January 21)\n        if (this.shouldSkipYearLikeDate) {\n            if (!match[DATE_TO_GROUP] && !match[YEAR_GROUP] && match[DATE_GROUP].match(/^2[0-5]$/)) {\n                return null;\n            }\n        }\n        const components = context\n            .createParsingComponents({\n                day: day,\n                month: month,\n            })\n            .addTag(\"parser/ENMonthNameMiddleEndianParser\");\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `((?:in)\\\\s*)?` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `(?:,|-|of)?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - January, 2012\n * - January 2012\n * - January\n * (in) Jan\n */\nexport default class ENMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"jan\", \"mar\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(\n            match.index + (match[PREFIX_GROUP] || \"\").length,\n            match.index + match[0].length\n        );\n        result.start.imply(\"day\", 1);\n        result.start.addTag(\"parser/ENMonthNameParser\");\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[-\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class ENYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMonthDateOrder: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        let day = parseInt(match[DATE_NUMBER_GROUP]);\n        let month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            if (this.strictMonthDateOrder) {\n                return null;\n            }\n            if (day >= 1 && day <= 12) {\n                [month, day] = [day, month];\n            }\n        }\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\"([0-9]|0[1-9]|1[012])/([0-9]{4})\" + \"\", \"i\");\n\nconst MONTH_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * Month/Year date format with slash \"/\" (also \"-\" and \".\") between numbers\n * - 11/05\n * - 06/2005\n */\nexport default class ENSlashMonthFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const year = parseInt(match[YEAR_GROUP]);\n        const month = parseInt(match[MONTH_GROUP]);\n\n        return context.createParsingComponents().imply(\"day\", 1).assign(\"month\", month).assign(\"year\", year);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Meridiem } from \"../../types\";\n\n// prettier-ignore\nfunction primaryTimePattern(leftBoundary: string, primaryPrefix: string, primarySuffix: string, flags: string) {\n    return new RegExp(\n            `${leftBoundary}` +\n            `${primaryPrefix}` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|:|：)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?::|：)` +\n                    `(\\\\d{2})` +\n                    `(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${primarySuffix}`,\n        flags\n    );\n}\n\n// prettier-ignore\nfunction followingTimePatten(followingPhase: string, followingSuffix: string) {\n    return new RegExp(\n        `^(${followingPhase})` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|\\\\:|\\\\：)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?:\\\\.|\\\\:|\\\\：)` +\n                    `(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${followingSuffix}`,\n        \"i\"\n    );\n}\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst MILLI_SECOND_GROUP = 5;\nconst AM_PM_HOUR_GROUP = 6;\n\nexport abstract class AbstractTimeExpressionParser implements Parser {\n    abstract primaryPrefix(): string;\n    abstract followingPhase(): string;\n    strictMode: boolean;\n\n    constructor(strictMode = false) {\n        this.strictMode = strictMode;\n    }\n\n    patternFlags(): string {\n        return \"i\";\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|\\\\b)`;\n    }\n\n    primarySuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    followingSuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    pattern(context: ParsingContext): RegExp {\n        return this.getPrimaryTimePatternThroughCache();\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const startComponents = this.extractPrimaryTimeComponents(context, match);\n        if (!startComponents) {\n            // If the match seem like a year e.g. \"2013.12:...\",\n            // then skips the year part and try matching again.\n            if (match[0].match(/^\\d{4}/)) {\n                match.index += 4; // Skip over potential overlapping pattern\n                return null;\n            }\n\n            match.index += match[0].length; // Skip over potential overlapping pattern\n            return null;\n        }\n\n        const index = match.index + match[1].length;\n        const text = match[0].substring(match[1].length);\n        const result = context.createParsingResult(index, text, startComponents);\n        match.index += match[0].length; // Skip over potential overlapping pattern\n\n        const remainingText = context.text.substring(match.index);\n        const followingPattern = this.getFollowingTimePatternThroughCache();\n        const followingMatch = followingPattern.exec(remainingText);\n\n        // Pattern \"456-12\", \"2022-12\" should not be time without proper context\n        if (text.match(/^\\d{3,4}/) && followingMatch) {\n            // e.g. \"2022-12\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2,4}$/)) {\n                return null;\n            }\n            // e.g. \"2022-12:01...\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2}\\W\\d{2}/)) {\n                return null;\n            }\n        }\n\n        if (\n            !followingMatch ||\n            // Pattern \"YY.YY -XXXX\" is more like timezone offset\n            followingMatch[0].match(/^\\s*([+-])\\s*\\d{3,4}$/)\n        ) {\n            return this.checkAndReturnWithoutFollowingPattern(result);\n        }\n\n        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);\n        if (result.end) {\n            result.text += followingMatch[0];\n        }\n\n        return this.checkAndReturnWithFollowingPattern(result);\n    }\n\n    extractPrimaryTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        strict = false\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        let hour = parseInt(match[HOUR_GROUP]);\n        if (hour > 100) {\n            if (this.strictMode || match[MINUTE_GROUP] != null) {\n                return null;\n            }\n\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {\n                // Skip single digit minute e.g. \"at 1.1 xx\"\n                return null;\n            }\n\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem !== null) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                components.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        return components;\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        let hour = parseInt(match[HOUR_GROUP]);\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Minute\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) {\n                return null;\n            }\n\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                    if (!components.isCertain(\"day\")) {\n                        components.imply(\"day\", components.get(\"day\") + 1);\n                    }\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == Meridiem.AM) {\n                    result.start.imply(\"meridiem\", Meridiem.AM);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", Meridiem.PM);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"hour\") > 12;\n            if (startAtPM) {\n                if (result.start.get(\"hour\") - 12 > hour) {\n                    // 10pm - 1 (am)\n                    components.imply(\"meridiem\", Meridiem.AM);\n                } else if (hour <= 12) {\n                    components.assign(\"hour\", hour + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                }\n            } else if (hour > 12) {\n                components.imply(\"meridiem\", Meridiem.PM);\n            } else if (hour <= 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (components.date().getTime() < result.start.date().getTime()) {\n            components.imply(\"day\", components.get(\"day\") + 1);\n        }\n\n        return components;\n    }\n\n    private checkAndReturnWithoutFollowingPattern(result) {\n        // Single digit (e.g \"1\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d$/)) {\n            return null;\n        }\n\n        // Three or more digit (e.g. \"203\", \"2014\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d\\d\\d+$/)) {\n            return null;\n        }\n\n        // Instead of \"am/pm\", it ends with \"a\" or \"p\" (e.g \"1a\", \"123p\"), this seems unlikely\n        if (result.text.match(/\\d[apAP]$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            const endingNumbers: string = endingWithNumbers[1];\n\n            // In strict mode (e.g. \"at 1\" or \"at 1.2\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            if (endingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private checkAndReturnWithFollowingPattern(result) {\n        if (result.text.match(/^\\d+-\\d+$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)\\s*-\\s*(\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            // In strict mode (e.g. \"at 1-3\" or \"at 1.2 - 2.3\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            const startingNumbers: string = endingWithNumbers[1];\n            const endingNumbers: string = endingWithNumbers[2];\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            const startingNumberVal = parseInt(startingNumbers);\n            if (endingNumberVal > 24 || startingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private cachedPrimaryPrefix = null;\n    private cachedPrimarySuffix = null;\n    private cachedPrimaryTimePattern = null;\n\n    getPrimaryTimePatternThroughCache() {\n        const primaryPrefix = this.primaryPrefix();\n        const primarySuffix = this.primarySuffix();\n\n        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {\n            return this.cachedPrimaryTimePattern;\n        }\n\n        this.cachedPrimaryTimePattern = primaryTimePattern(\n            this.primaryPatternLeftBoundary(),\n            primaryPrefix,\n            primarySuffix,\n            this.patternFlags()\n        );\n        this.cachedPrimaryPrefix = primaryPrefix;\n        this.cachedPrimarySuffix = primarySuffix;\n        return this.cachedPrimaryTimePattern;\n    }\n\n    private cachedFollowingPhase = null;\n    private cachedFollowingSuffix = null;\n    private cachedFollowingTimePatten = null;\n\n    getFollowingTimePatternThroughCache() {\n        const followingPhase = this.followingPhase();\n        const followingSuffix = this.followingSuffix();\n\n        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {\n            return this.cachedFollowingTimePatten;\n        }\n\n        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);\n        this.cachedFollowingPhase = followingPhase;\n        this.cachedFollowingSuffix = followingSuffix;\n        return this.cachedFollowingTimePatten;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class ENTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|to|until|through|till|\\\\?)\\\\s*\";\n    }\n\n    primaryPrefix(): string {\n        return \"(?:(?:at|from)\\\\s*)??\";\n    }\n\n    primarySuffix(): string {\n        return \"(?:\\\\s*(?:o\\\\W*clock|at\\\\s*night|in\\\\s*the\\\\s*(?:morning|afternoon)))?(?!/)(?=\\\\W|$)\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (!components) {\n            return components;\n        }\n\n        if (match[0].endsWith(\"night\")) {\n            const hour = components.get(\"hour\");\n            if (hour >= 6 && hour < 12) {\n                components.assign(\"hour\", components.get(\"hour\") + 12);\n                components.assign(\"meridiem\", Meridiem.PM);\n            } else if (hour < 6) {\n                components.assign(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (match[0].endsWith(\"afternoon\")) {\n            components.assign(\"meridiem\", Meridiem.PM);\n            const hour = components.get(\"hour\");\n            if (hour >= 0 && hour <= 6) {\n                components.assign(\"hour\", components.get(\"hour\") + 12);\n            }\n        }\n\n        if (match[0].endsWith(\"morning\")) {\n            components.assign(\"meridiem\", Meridiem.AM);\n            const hour = components.get(\"hour\");\n            if (hour < 12) {\n                components.assign(\"hour\", components.get(\"hour\"));\n            }\n        }\n\n        return components.addTag(\"parser/ENTimeExpressionParser\");\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): ParsingComponents | null {\n        const followingComponents = super.extractFollowingTimeComponents(context, match, result);\n        if (followingComponents) {\n            followingComponents.addTag(\"parser/ENTimeExpressionParser\");\n        }\n        return followingComponents;\n    }\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { ParsingComponents } from \"../results\";\n\nexport type TimeUnits = { [c in OpUnitType | QUnitType]?: number };\n\nexport function reverseTimeUnits(timeUnits: TimeUnits): TimeUnits {\n    const reversed = {};\n    for (const key in timeUnits) {\n        // noinspection JSUnfilteredForInLoop\n        reversed[key] = -timeUnits[key];\n    }\n\n    return reversed as TimeUnits;\n}\n\nexport function addImpliedTimeUnits(components: ParsingComponents, timeUnits: TimeUnits): ParsingComponents {\n    const output = components.clone();\n\n    let date = components.dayjs();\n    for (const key in timeUnits) {\n        // noinspection JSUnfilteredForInLoop,TypeScriptValidateTypes\n        date = date.add(timeUnits[key], key as QUnitType);\n    }\n\n    if (\"day\" in timeUnits || \"d\" in timeUnits || \"week\" in timeUnits || \"month\" in timeUnits || \"year\" in timeUnits) {\n        output.imply(\"day\", date.date());\n        output.imply(\"month\", date.month() + 1);\n        output.imply(\"year\", date.year());\n    }\n\n    if (\"second\" in timeUnits || \"minute\" in timeUnits || \"hour\" in timeUnits) {\n        output.imply(\"second\", date.second());\n        output.imply(\"minute\", date.minute());\n        output.imply(\"hour\", date.hour());\n    }\n\n    return output;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nconst PATTERN = new RegExp(`(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:ago|before|earlier)(?=\\\\W|$)`, \"i\");\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\\\s{0,5}(?:ago|before|earlier)(?=\\\\W|$)`, \"i\");\n\nexport default class ENTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[1]);\n        if (!timeUnits) {\n            return null;\n        }\n        const outputTimeUnits = reverseTimeUnits(timeUnits);\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:later|after|from now|henceforth|forward|out)` + \"(?=(?:\\\\W|$))\",\n    \"i\"\n);\n\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\\\s{0,5}(later|after|from now)(?=\\\\W|$)`, \"i\");\nconst GROUP_NUM_TIMEUNITS = 1;\n\nexport default class ENTimeUnitLaterFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);\n        if (!timeUnits) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext, Refiner } from \"../chrono\";\nimport { ParsingResult } from \"../results\";\n\n/**\n * A special type of {@link Refiner} to filter the results\n */\nexport abstract class Filter implements Refiner {\n    abstract isValid(context: ParsingContext, result: ParsingResult): boolean;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        return results.filter((r) => this.isValid(context, r));\n    }\n}\n\n/**\n * A special type of {@link Refiner} to merge consecutive results\n */\nexport abstract class MergingRefiner implements Refiner {\n    abstract shouldMergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): boolean;\n\n    abstract mergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): ParsingResult;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const mergedResults: ParsingResult[] = [];\n        let curResult = results[0];\n        let nextResult = null;\n\n        for (let i = 1; i < results.length; i++) {\n            nextResult = results[i];\n\n            const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);\n            if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {\n                mergedResults.push(curResult);\n                curResult = nextResult;\n            } else {\n                const left = curResult;\n                const right = nextResult;\n                const mergedResult = this.mergeResults(textBetween, left, right, context);\n                context.debug(() => {\n                    console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);\n                });\n\n                curResult = mergedResult;\n            }\n        }\n\n        if (curResult != null) {\n            mergedResults.push(curResult);\n        }\n\n        return mergedResults;\n    }\n}\n", "/*\n  \n*/\n\nimport { ParsingResult } from \"../../results\";\nimport { MergingRefiner } from \"../abstractRefiners\";\n\nexport default abstract class AbstractMergeDateRangeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween, currentResult, nextResult): boolean {\n        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;\n    }\n\n    mergeResults(textBetween, fromResult, toResult): ParsingResult {\n        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {\n            toResult.start.getCertainComponents().forEach((key) => {\n                if (!fromResult.start.isCertain(key)) {\n                    fromResult.start.imply(key, toResult.start.get(key));\n                }\n            });\n\n            fromResult.start.getCertainComponents().forEach((key) => {\n                if (!toResult.start.isCertain(key)) {\n                    toResult.start.imply(key, fromResult.start.get(key));\n                }\n            });\n        }\n\n        if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {\n            let fromMoment = fromResult.start.dayjs();\n            let toMoment = toResult.start.dayjs();\n            if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, \"days\").isAfter(fromMoment)) {\n                toMoment = toMoment.add(7, \"days\");\n                toResult.start.imply(\"day\", toMoment.date());\n                toResult.start.imply(\"month\", toMoment.month() + 1);\n                toResult.start.imply(\"year\", toMoment.year());\n            } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, \"days\").isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-7, \"days\");\n                fromResult.start.imply(\"day\", fromMoment.date());\n                fromResult.start.imply(\"month\", fromMoment.month() + 1);\n                fromResult.start.imply(\"year\", fromMoment.year());\n            } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, \"years\").isAfter(fromMoment)) {\n                toMoment = toMoment.add(1, \"years\");\n                toResult.start.imply(\"year\", toMoment.year());\n            } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, \"years\").isBefore(toMoment)) {\n                fromMoment = fromMoment.add(-1, \"years\");\n                fromResult.start.imply(\"year\", fromMoment.year());\n            } else {\n                [toResult, fromResult] = [fromResult, toResult];\n            }\n        }\n\n        const result = fromResult.clone();\n        result.start = fromResult.start;\n        result.end = toResult.start;\n        result.index = Math.min(fromResult.index, toResult.index);\n        if (fromResult.index < toResult.index) {\n            result.text = fromResult.text + textBetween + toResult.text;\n        } else {\n            result.text = toResult.text + textBetween + fromResult.text;\n        }\n\n        return result;\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide English connecting phases\n * - 2020-02-13 [to] 2020-02-13\n * - Wednesday [-] Friday\n */\nexport default class ENMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(to|-|–|until|through|till)\\s*$/i;\n    }\n}\n", "import { ParsingComponents, ParsingResult } from \"../results\";\nimport { Meridiem } from \"../types\";\nimport { assignSimilarDate, implySimilarDate } from \"../utils/dayjs\";\n\nexport function mergeDateTimeResult(dateResult: ParsingResult, timeResult: ParsingResult): ParsingResult {\n    const result = dateResult.clone();\n    const beginDate = dateResult.start;\n    const beginTime = timeResult.start;\n\n    result.start = mergeDateTimeComponent(beginDate, beginTime);\n    if (dateResult.end != null || timeResult.end != null) {\n        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;\n        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;\n        const endDateTime = mergeDateTimeComponent(endDate, endTime);\n\n        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {\n            // For example,  \"Tuesday 9pm - 1am\" the ending should actually be 1am on the next day.\n            // We need to add to ending by another day.\n            const nextDayJs = endDateTime.dayjs().add(1, \"day\");\n            if (endDateTime.isCertain(\"day\")) {\n                assignSimilarDate(endDateTime, nextDayJs);\n            } else {\n                implySimilarDate(endDateTime, nextDayJs);\n            }\n        }\n\n        result.end = endDateTime;\n    }\n\n    return result;\n}\n\nexport function mergeDateTimeComponent(\n    dateComponent: ParsingComponents,\n    timeComponent: ParsingComponents\n): ParsingComponents {\n    const dateTimeComponent = dateComponent.clone();\n\n    if (timeComponent.isCertain(\"hour\")) {\n        dateTimeComponent.assign(\"hour\", timeComponent.get(\"hour\"));\n        dateTimeComponent.assign(\"minute\", timeComponent.get(\"minute\"));\n\n        if (timeComponent.isCertain(\"second\")) {\n            dateTimeComponent.assign(\"second\", timeComponent.get(\"second\"));\n\n            if (timeComponent.isCertain(\"millisecond\")) {\n                dateTimeComponent.assign(\"millisecond\", timeComponent.get(\"millisecond\"));\n            } else {\n                dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n            }\n        } else {\n            dateTimeComponent.imply(\"second\", timeComponent.get(\"second\"));\n            dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n        }\n    } else {\n        dateTimeComponent.imply(\"hour\", timeComponent.get(\"hour\"));\n        dateTimeComponent.imply(\"minute\", timeComponent.get(\"minute\"));\n        dateTimeComponent.imply(\"second\", timeComponent.get(\"second\"));\n        dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n    }\n\n    if (timeComponent.isCertain(\"timezoneOffset\")) {\n        dateTimeComponent.assign(\"timezoneOffset\", timeComponent.get(\"timezoneOffset\"));\n    }\n\n    if (timeComponent.isCertain(\"meridiem\")) {\n        dateTimeComponent.assign(\"meridiem\", timeComponent.get(\"meridiem\"));\n    } else if (timeComponent.get(\"meridiem\") != null && dateTimeComponent.get(\"meridiem\") == null) {\n        dateTimeComponent.imply(\"meridiem\", timeComponent.get(\"meridiem\"));\n    }\n\n    if (dateTimeComponent.get(\"meridiem\") == Meridiem.PM && dateTimeComponent.get(\"hour\") < 12) {\n        if (timeComponent.isCertain(\"hour\")) {\n            dateTimeComponent.assign(\"hour\", dateTimeComponent.get(\"hour\") + 12);\n        } else {\n            dateTimeComponent.imply(\"hour\", dateTimeComponent.get(\"hour\") + 12);\n        }\n    }\n\n    dateTimeComponent.addTags(dateComponent.tags());\n    dateTimeComponent.addTags(timeComponent.tags());\n    return dateTimeComponent;\n}\n", "/*\n\n*/\n\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\nimport { mergeDateTimeResult } from \"../../calculation/mergingCalculation\";\n\nexport default abstract class AbstractMergeDateTimeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        return (\n            ((currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime()) ||\n                (nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime())) &&\n            textBetween.match(this.patternBetween()) != null\n        );\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const result = currentResult.start.isOnlyDate()\n            ? mergeDateTimeResult(currentResult, nextResult)\n            : mergeDateTimeResult(nextResult, currentResult);\n\n        result.index = currentResult.index;\n        result.text = currentResult.text + textBetween + nextResult.text;\n        return result;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide English connecting phases\n * - 2020-02-13 [at] 6pm\n * - Tomorrow [after] 7am\n */\nexport default class ENMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|at|after|before|on|of|,|-|\\\\.|∙|:)?\\\\s*$\");\n    }\n}\n", "// Map ABBR -> Offset in minute\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { TimezoneAbbrMap } from \"../../types\";\nimport { ParsingResult } from \"../../results\";\nimport { toTimezoneOffset } from \"../../timezone\";\n\nconst TIMEZONE_NAME_PATTERN = new RegExp(\"^\\\\s*,?\\\\s*\\\\(?([A-Z]{2,4})\\\\)?(?=\\\\W|$)\", \"i\");\n\nexport default class ExtractTimezoneAbbrRefiner implements Refiner {\n    constructor(private readonly timezoneOverrides?: TimezoneAbbrMap) {}\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        const timezoneOverrides = context.option.timezones ?? {};\n\n        results.forEach((result) => {\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_NAME_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            const timezoneAbbr = match[1].toUpperCase();\n            const refDate = result.start.date() ?? result.refDate ?? new Date();\n            const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };\n            const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);\n            if (extractedTimezoneOffset == null) {\n                return;\n            }\n            context.debug(() => {\n                console.log(\n                    `Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`\n                );\n            });\n\n            const currentTimezoneOffset = result.start.get(\"timezoneOffset\");\n            if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {\n                // We may already have extracted the timezone offset e.g. \"11 am GMT+0900 (JST)\"\n                // - if they are equal, we also want to take the abbreviation text into result\n                // - if they are not equal, we trust the offset more\n                if (result.start.isCertain(\"timezoneOffset\")) {\n                    return;\n                }\n\n                // This is often because it's relative time with inferred timezone (e.g. in 1 hour, tomorrow)\n                // Then, we want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            if (result.start.isOnlyDate()) {\n                // If the time is not explicitly mentioned,\n                // Then, we also want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            result.text += match[0];\n\n            if (!result.start.isCertain(\"timezoneOffset\")) {\n                result.start.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n\n            if (result.end != null && !result.end.isCertain(\"timezoneOffset\")) {\n                result.end.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n        });\n\n        return results;\n    }\n}\n", "import { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\n\nconst TIMEZONE_OFFSET_PATTERN = new RegExp(\"^\\\\s*(?:\\\\(?(?:GMT|UTC)\\\\s?)?([+-])(\\\\d{1,2})(?::?(\\\\d{2}))?\\\\)?\", \"i\");\nconst TIMEZONE_OFFSET_SIGN_GROUP = 1;\nconst TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;\nconst TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;\n\nexport default class ExtractTimezoneOffsetRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (result.start.isCertain(\"timezoneOffset\")) {\n                return;\n            }\n\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            context.debug(() => {\n                console.log(`Extracting timezone: '${match[0]}' into : ${result}`);\n            });\n\n            const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);\n            const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || \"0\");\n            let timezoneOffset = hourOffset * 60 + minuteOffset;\n            // No timezones have offsets greater than 14 hours, so disregard this match\n            if (timezoneOffset > 14 * 60) {\n                return;\n            }\n            if (match[TIMEZONE_OFFSET_SIGN_GROUP] === \"-\") {\n                timezoneOffset = -timezoneOffset;\n            }\n\n            if (result.end != null) {\n                result.end.assign(\"timezoneOffset\", timezoneOffset);\n            }\n\n            result.start.assign(\"timezoneOffset\", timezoneOffset);\n            result.text += match[0];\n        });\n\n        return results;\n    }\n}\n", "/*\n  \n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\n\nexport default class OverlapRemovalRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const filteredResults = [];\n        let prevResult = results[0];\n        for (let i = 1; i < results.length; i++) {\n            const result = results[i];\n            if (result.index >= prevResult.index + prevResult.text.length) {\n                filteredResults.push(prevResult);\n                prevResult = result;\n                continue;\n            }\n\n            // If overlap, compare the length and discard the shorter one\n            let kept = null;\n            let removed = null;\n            if (result.text.length > prevResult.text.length) {\n                kept = result;\n                removed = prevResult;\n            } else {\n                kept = prevResult;\n                removed = result;\n            }\n            context.debug(() => {\n                console.log(`${this.constructor.name} remove ${removed} by ${kept}`);\n            });\n            prevResult = kept;\n        }\n\n        // The last one\n        if (prevResult != null) {\n            filteredResults.push(prevResult);\n        }\n\n        return filteredResults;\n    }\n}\n", "/*\n    Enforce 'forwardDate' option to on the results. When there are missing component,\n    e.g. \"March 12-13 (without year)\" or \"Thursday\", the refiner will try to adjust the result\n    into the future instead of the past.\n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport dayjs from \"dayjs\";\nimport { implySimilarDate } from \"../../utils/dayjs\";\nimport * as dates from \"../../utils/dates\";\n\nexport default class ForwardDateRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (!context.option.forwardDate) {\n            return results;\n        }\n\n        results.forEach((result) => {\n            let refMoment = dayjs(context.reference.getDateWithAdjustedTimezone());\n\n            if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {\n                const refDate = context.reference.getDateWithAdjustedTimezone();\n                const refFollowingDay = new Date(refDate);\n                refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n\n                dates.implySimilarDate(result.start, refFollowingDay);\n                context.debug(() => {\n                    console.log(\n                        `${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`\n                    );\n                });\n                if (result.end && result.end.isOnlyTime()) {\n                    dates.implySimilarDate(result.end, refFollowingDay);\n                    if (result.start.date() > result.end.date()) {\n                        refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n                        dates.implySimilarDate(result.end, refFollowingDay);\n                    }\n                }\n            }\n\n            if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {\n                if (refMoment.day() >= result.start.get(\"weekday\")) {\n                    refMoment = refMoment.day(result.start.get(\"weekday\") + 7);\n                } else {\n                    refMoment = refMoment.day(<number>result.start.get(\"weekday\"));\n                }\n\n                result.start.imply(\"day\", refMoment.date());\n                result.start.imply(\"month\", refMoment.month() + 1);\n                result.start.imply(\"year\", refMoment.year());\n                context.debug(() => {\n                    console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);\n                });\n\n                if (result.end && result.end.isOnlyWeekdayComponent()) {\n                    // Adjust date to the coming week\n                    if (refMoment.day() > result.end.get(\"weekday\")) {\n                        refMoment = refMoment.day(result.end.get(\"weekday\") + 7);\n                    } else {\n                        refMoment = refMoment.day(<number>result.end.get(\"weekday\"));\n                    }\n\n                    result.end.imply(\"day\", refMoment.date());\n                    result.end.imply(\"month\", refMoment.month() + 1);\n                    result.end.imply(\"year\", refMoment.year());\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);\n                    });\n                }\n            }\n\n            // In case where we know the month, but not which year (e.g. \"in December\", \"25th December\"),\n            // try move to another year\n            if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {\n                for (let i = 0; i < 3 && refMoment.isAfter(result.start.dayjs()); i++) {\n                    result.start.imply(\"year\", result.start.get(\"year\") + 1);\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);\n                    });\n\n                    if (result.end && !result.end.isCertain(\"year\")) {\n                        result.end.imply(\"year\", result.end.get(\"year\") + 1);\n                        context.debug(() => {\n                            console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);\n                        });\n                    }\n                }\n            }\n        });\n\n        return results;\n    }\n}\n", "import { ParsingComponents } from \"../results\";\n\n/**\n * Imply (weakly update) the parsing component to the same day as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function implySimilarDate(component: ParsingComponents, target: Date) {\n    component.imply(\"day\", target.getDate());\n    component.imply(\"month\", target.getMonth() + 1);\n    component.imply(\"year\", target.getFullYear());\n}\n\n/**\n * Imply (weakly update) the parsing component to the same time as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function implySimilarTime(component: ParsingComponents, target: Date) {\n    component.imply(\"hour\", target.getHours());\n    component.imply(\"minute\", target.getMinutes());\n    component.imply(\"second\", target.getSeconds());\n    component.imply(\"millisecond\", target.getMilliseconds());\n}\n", "import { Filter } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\n\nexport default class UnlikelyFormatFilter extends Filter {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    isValid(context, result: ParsingResult): boolean {\n        if (result.text.replace(\" \", \"\").match(/^\\d*(\\.\\d*)?$/)) {\n            context.debug(() => {\n                console.log(`Removing unlikely result '${result.text}'`);\n            });\n\n            return false;\n        }\n\n        if (!result.start.isValidDate()) {\n            context.debug(() => {\n                console.log(`Removing invalid result: ${result} (${result.start})`);\n            });\n\n            return false;\n        }\n\n        if (result.end && !result.end.isValidDate()) {\n            context.debug(() => {\n                console.log(`Removing invalid result: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        if (this.strictMode) {\n            return this.isStrictModeValid(context, result);\n        }\n\n        return true;\n    }\n\n    private isStrictModeValid(context, result: ParsingResult) {\n        if (result.start.isOnlyWeekdayComponent()) {\n            context.debug(() => {\n                console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        if (result.start.isOnlyTime() && (!result.start.isCertain(\"hour\") || !result.start.isCertain(\"minute\"))) {\n            context.debug(() => {\n                console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        return true;\n    }\n}\n", "import { ParsingContext } from \"../../chrono\";\nimport { Component } from \"../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"./AbstractParserWithWordBoundary\";\n\n// ISO 8601\n// http://www.w3.org/TR/NOTE-datetime\n// - YYYY-MM-DD\n// - YYYY-MM-DDThh:mmTZD\n// - YYYY-MM-DDThh:mm:ssTZD\n// - YYYY-MM-DDThh:mm:ss.sTZD\n// - TZD = (Z or +hh:mm or -hh:mm)\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    \"([0-9]{4})\\\\-([0-9]{1,2})\\\\-([0-9]{1,2})\" +\n    \"(?:T\" + //..\n        \"([0-9]{1,2}):([0-9]{1,2})\" + // hh:mm\n        \"(?:\" +\n            \":([0-9]{1,2})(?:\\\\.(\\\\d{1,4}))?\" +\n        \")?\" + // :ss.s\n        \"(\" +\n            \"Z|([+-]\\\\d{2}):?(\\\\d{2})?\" +\n        \")?\" + // TZD (Z or ±hh:mm or ±hhmm or ±hh)\n    \")?\" +\n    \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NUMBER_GROUP = 2;\nconst DATE_NUMBER_GROUP = 3;\nconst HOUR_NUMBER_GROUP = 4;\nconst MINUTE_NUMBER_GROUP = 5;\nconst SECOND_NUMBER_GROUP = 6;\nconst MILLISECOND_NUMBER_GROUP = 7;\nconst TZD_GROUP = 8;\nconst TZD_HOUR_OFFSET_GROUP = 9;\nconst TZD_MINUTE_OFFSET_GROUP = 10;\n\nexport default class ISOFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const components = context.createParsingComponents({\n            \"year\": parseInt(match[YEAR_NUMBER_GROUP]),\n            \"month\": parseInt(match[MONTH_NUMBER_GROUP]),\n            \"day\": parseInt(match[DATE_NUMBER_GROUP]),\n        });\n        if (match[HOUR_NUMBER_GROUP] != null) {\n            components.assign(\"hour\", parseInt(match[HOUR_NUMBER_GROUP]));\n            components.assign(\"minute\", parseInt(match[MINUTE_NUMBER_GROUP]));\n\n            if (match[SECOND_NUMBER_GROUP] != null) {\n                components.assign(\"second\", parseInt(match[SECOND_NUMBER_GROUP]));\n            }\n\n            if (match[MILLISECOND_NUMBER_GROUP] != null) {\n                components.assign(\"millisecond\", parseInt(match[MILLISECOND_NUMBER_GROUP]));\n            }\n            if (match[TZD_GROUP] != null) {\n                // The Zulu time zone (Z) is equivalent to UTC\n                let offset = 0;\n                if (match[TZD_HOUR_OFFSET_GROUP]) {\n                    const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);\n                    let minuteOffset = 0;\n                    if (match[TZD_MINUTE_OFFSET_GROUP] != null) {\n                        minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);\n                    }\n                    offset = hourOffset * 60;\n                    if (offset < 0) {\n                        offset -= minuteOffset;\n                    } else {\n                        offset += minuteOffset;\n                    }\n                }\n                components.assign(\"timezoneOffset\", offset);\n            }\n        }\n        return components.addTag(\"parser/ISOFormatParser\");\n    }\n}\n", "/*\n  \n*/\n\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\n\n/**\n * Merge weekday component into more completed data\n * - [Sunday] [12/7/2014] => [Sunday 12/7/2014]\n * - [Tuesday], [January 13, 2012] => [Sunday 12/7/2014]\n */\nexport default class MergeWeekdayComponentRefiner extends MergingRefiner {\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const newResult = nextResult.clone();\n        newResult.index = currentResult.index;\n        newResult.text = currentResult.text + textBetween + newResult.text;\n\n        newResult.start.assign(\"weekday\", currentResult.start.get(\"weekday\"));\n        if (newResult.end) {\n            newResult.end.assign(\"weekday\", currentResult.start.get(\"weekday\"));\n        }\n\n        return newResult;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        const weekdayThenNormalDate =\n            currentResult.start.isOnlyWeekdayComponent() &&\n            !currentResult.start.isCertain(\"hour\") &&\n            nextResult.start.isCertain(\"day\");\n        return weekdayThenNormalDate && textBetween.match(/^,?\\s*$/) != null;\n    }\n}\n", "import { Configuration, Parser, Refiner } from \"./chrono\";\n\nimport ExtractTimezoneAbbrRefiner from \"./common/refiners/ExtractTimezoneAbbrRefiner\";\nimport ExtractTimezoneOffsetRefiner from \"./common/refiners/ExtractTimezoneOffsetRefiner\";\nimport OverlapRemovalRefiner from \"./common/refiners/OverlapRemovalRefiner\";\nimport ForwardDateRefiner from \"./common/refiners/ForwardDateRefiner\";\nimport UnlikelyFormatFilter from \"./common/refiners/UnlikelyFormatFilter\";\nimport ISOFormatParser from \"./common/parsers/ISOFormatParser\";\nimport MergeWeekdayComponentRefiner from \"./common/refiners/MergeWeekdayComponentRefiner\";\n\nexport function includeCommonConfiguration(configuration: Configuration, strictMode = false): Configuration {\n    configuration.parsers.unshift(new ISOFormatParser());\n\n    configuration.refiners.unshift(new MergeWeekdayComponentRefiner());\n    configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner());\n    configuration.refiners.unshift(new OverlapRemovalRefiner());\n\n    // Unlike ExtractTimezoneOffsetRefiner, this refiner relies on knowing both date and time in cases where the tz\n    // is ambiguous (in terms of DST/non-DST). It therefore needs to be applied as late as possible in the parsing.\n    configuration.refiners.push(new ExtractTimezoneAbbrRefiner());\n    configuration.refiners.push(new OverlapRemovalRefiner());\n    configuration.refiners.push(new ForwardDateRefiner());\n    configuration.refiners.push(new UnlikelyFormatFilter(strictMode));\n    return configuration;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dayjs\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\\s*night)(?=\\W|$)/i;\n\nexport default class ENCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = dayjs(context.refDate);\n        const lowerText = match[0].toLowerCase();\n        let component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"now\":\n                component = references.now(context.reference);\n                break;\n\n            case \"today\":\n                component = references.today(context.reference);\n                break;\n\n            case \"yesterday\":\n                component = references.yesterday(context.reference);\n                break;\n\n            case \"tomorrow\":\n            case \"tmr\":\n            case \"tmrw\":\n                component = references.tomorrow(context.reference);\n                break;\n\n            case \"tonight\":\n                component = references.tonight(context.reference);\n                break;\n\n            case \"overmorrow\":\n                component = references.theDayAfter(context.reference, 2);\n                break;\n\n            default:\n                if (lowerText.match(/last\\s*night/)) {\n                    if (targetDate.hour() > 6) {\n                        targetDate = targetDate.add(-1, \"day\");\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n                break;\n        }\n        component.addTag(\"parser/ENCasualDateParser\");\n        return component;\n    }\n}\n", "import { ParsingComponents, ReferenceWithTimezone } from \"../results\";\nimport dayjs from \"dayjs\";\nimport {\n    assignSimilarDate,\n    assignSimilarTime,\n    implySimilarDate,\n    implySimilarTime,\n    implyTheNextDay,\n} from \"../utils/dayjs\";\nimport { Meridiem } from \"../types\";\n\nexport function now(reference: ReferenceWithTimezone): ParsingComponents {\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    assignSimilarTime(component, targetDate);\n    component.assign(\"timezoneOffset\", reference.getTimezoneOffset());\n    component.addTag(\"casualReference/now\");\n    return component;\n}\n\nexport function today(reference: ReferenceWithTimezone): ParsingComponents {\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    implySimilarTime(component, targetDate);\n    component.addTag(\"casualReference/today\");\n    return component;\n}\n\n/**\n * The previous day. Imply the same time.\n */\nexport function yesterday(reference: ReferenceWithTimezone): ParsingComponents {\n    return theDayBefore(reference, 1).addTag(\"casualReference/yesterday\");\n}\n\nexport function theDayBefore(reference: ReferenceWithTimezone, numDay: number): ParsingComponents {\n    return theDayAfter(reference, -numDay);\n}\n\n/**\n * The following day with dayjs.assignTheNextDay()\n */\nexport function tomorrow(reference: ReferenceWithTimezone): ParsingComponents {\n    return theDayAfter(reference, 1).addTag(\"casualReference/tomorrow\");\n}\n\nexport function theDayAfter(reference: ReferenceWithTimezone, nDays: number): ParsingComponents {\n    let targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    targetDate = targetDate.add(nDays, \"day\");\n    assignSimilarDate(component, targetDate);\n    implySimilarTime(component, targetDate);\n    return component;\n}\n\nexport function tonight(reference: ReferenceWithTimezone, implyHour = 22): ParsingComponents {\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.addTag(\"casualReference/tonight\");\n    return component;\n}\n\nexport function lastNight(reference: ReferenceWithTimezone, implyHour = 0): ParsingComponents {\n    let targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    if (targetDate.hour() < 6) {\n        targetDate = targetDate.add(-1, \"day\");\n    }\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    return component;\n}\n\nexport function evening(reference: ReferenceWithTimezone, implyHour = 20): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.imply(\"hour\", implyHour);\n    component.addTag(\"casualReference/evening\");\n    return component;\n}\n\nexport function yesterdayEvening(reference: ReferenceWithTimezone, implyHour = 20): ParsingComponents {\n    let targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    const component = new ParsingComponents(reference, {});\n    targetDate = targetDate.add(-1, \"day\");\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.addTag(\"casualReference/yesterday\");\n    component.addTag(\"casualReference/evening\");\n    return component;\n}\n\nexport function midnight(reference: ReferenceWithTimezone): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    const targetDate = dayjs(reference.getDateWithAdjustedTimezone());\n    if (targetDate.hour() > 2) {\n        // Unless it's very early morning (0~2AM), we assume the midnight is the coming midnight.\n        // Thus, increasing the day by 1.\n        implyTheNextDay(component, targetDate);\n    }\n    component.assign(\"hour\", 0);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/midnight\");\n    return component;\n}\n\nexport function morning(reference: ReferenceWithTimezone, implyHour = 6): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.AM);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/morning\");\n    return component;\n}\n\nexport function afternoon(reference: ReferenceWithTimezone, implyHour = 15): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/afternoon\");\n    return component;\n}\n\nexport function noon(reference: ReferenceWithTimezone): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.AM);\n    component.imply(\"hour\", 12);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/noon\");\n    return component;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as casualReferences from \"../../../common/casualReferences\";\n\nconst PATTERN = /(?:this)?\\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\\W|$)/i;\n\nexport default class ENCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return PATTERN;\n    }\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let component = null;\n        switch (match[1].toLowerCase()) {\n            case \"afternoon\":\n                component = casualReferences.afternoon(context.reference);\n                break;\n            case \"evening\":\n            case \"night\":\n                component = casualReferences.evening(context.reference);\n                break;\n            case \"midnight\":\n                component = casualReferences.midnight(context.reference);\n                break;\n            case \"morning\":\n                component = casualReferences.morning(context.reference);\n                break;\n            case \"noon\":\n            case \"midday\":\n                component = casualReferences.noon(context.reference);\n                break;\n        }\n        if (component) {\n            component.addTag(\"parser/ENCasualTimeParser\");\n        }\n        return component;\n    }\n}\n", "import { Weekday } from \"../../types\";\nimport { ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { addImpliedTimeUnits } from \"../../utils/timeunits\";\n\n/**\n * Returns the parsing components at the weekday (considering the modifier). The time and timezone is assume to be\n * similar to the reference.\n * @param reference\n * @param weekday\n * @param modifier \"this\", \"next\", \"last\" modifier word. If empty, returns the weekday closest to the `refDate`.\n */\nexport function createParsingComponentsAtWeekday(\n    reference: ReferenceWithTimezone,\n    weekday: Weekday,\n    modifier?: \"this\" | \"next\" | \"last\"\n): ParsingComponents {\n    const refDate = reference.getDateWithAdjustedTimezone();\n    const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);\n\n    let components = new ParsingComponents(reference);\n    components = addImpliedTimeUnits(components, { \"day\": daysToWeekday });\n    components.assign(\"weekday\", weekday);\n\n    return components;\n}\n\n/**\n * Returns number of days from refDate to the weekday. The refDate date and timezone information is used.\n * @param refDate\n * @param weekday\n * @param modifier \"this\", \"next\", \"last\" modifier word. If empty, returns the weekday closest to the `refDate`.\n */\nexport function getDaysToWeekday(refDate: Date, weekday: Weekday, modifier?: \"this\" | \"next\" | \"last\"): number {\n    const refWeekday = refDate.getDay() as Weekday;\n    switch (modifier) {\n        case \"this\":\n            return getDaysForwardToWeekday(refDate, weekday);\n        case \"last\":\n            return getBackwardDaysToWeekday(refDate, weekday);\n        case \"next\":\n            // From Sunday, the next Sunday is 7 days later.\n            // Otherwise, next Mon is 1 days later, next Tues is 2 days later, and so on..., (return enum value)\n            if (refWeekday == Weekday.SUNDAY) {\n                return weekday == Weekday.SUNDAY ? 7 : weekday;\n            }\n            // From Saturday, the next Saturday is 7 days later, the next Sunday is 8-days later.\n            // Otherwise, next Mon is (1 + 1) days later, next Tues is (1 + 2) days later, and so on...,\n            // (return, 2 + [enum value] days)\n            if (refWeekday == Weekday.SATURDAY) {\n                if (weekday == Weekday.SATURDAY) return 7;\n                if (weekday == Weekday.SUNDAY) return 8;\n                return 1 + weekday;\n            }\n            // From weekdays, next Mon is the following week's Mon, next Tues the following week's Tues, and so on...\n            // If the week's weekday already passed (weekday < refWeekday), we simply count forward to next week\n            // (similar to 'this'). Otherwise, count forward to this week, then add another 7 days.\n            if (weekday < refWeekday && weekday != Weekday.SUNDAY) {\n                return getDaysForwardToWeekday(refDate, weekday);\n            } else {\n                return getDaysForwardToWeekday(refDate, weekday) + 7;\n            }\n    }\n    return getDaysToWeekdayClosest(refDate, weekday);\n}\n\nexport function getDaysToWeekdayClosest(refDate: Date, weekday: Weekday): number {\n    const backward = getBackwardDaysToWeekday(refDate, weekday);\n    const forward = getDaysForwardToWeekday(refDate, weekday);\n\n    return forward < -backward ? forward : backward;\n}\n\nexport function getDaysForwardToWeekday(refDate: Date, weekday: Weekday): number {\n    const refWeekday = refDate.getDay();\n    let forwardCount = weekday - refWeekday;\n    if (forwardCount < 0) {\n        forwardCount += 7;\n    }\n    return forwardCount;\n}\n\nexport function getBackwardDaysToWeekday(refDate: Date, weekday: Weekday): number {\n    const refWeekday = refDate.getDay();\n    let backwardCount = weekday - refWeekday;\n    if (backwardCount >= 0) {\n        backwardCount -= 7;\n    }\n    return backwardCount;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\nimport { Weekday } from \"../../../types\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:on\\\\s*?)?\" +\n        \"(?:(this|last|past|next)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(this|last|past|next)\\\\s*week)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ENWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"last\" || modifierWord == \"past\") {\n            modifier = \"last\";\n        } else if (modifierWord == \"next\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"this\") {\n            modifier = \"this\";\n        }\n\n        const weekday_word = match[WEEKDAY_GROUP].toLowerCase();\n        let weekday;\n        if (WEEKDAY_DICTIONARY[weekday_word] !== undefined) {\n            weekday = WEEKDAY_DICTIONARY[weekday_word];\n        } else if (weekday_word == \"weekend\") {\n            // This depends on what days are weekend setting, but typically:\n            // 'This/next weekend' means the coming Saturday, 'last weekend' means last Sunday.\n            weekday = modifier == \"last\" ? Weekday.SUNDAY : Weekday.SATURDAY;\n        } else if (weekday_word == \"weekday\") {\n            // In English, the \"weekday\" means any day of the week except weekend.\n            // This also depends on what days are weekend setting, but typically:\n            // - On weekend ref, this means the coming Monday or last Friday.\n            // - On weekday ref, this means the next/last working day.\n            const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();\n            if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {\n                weekday = modifier == \"last\" ? Weekday.FRIDAY : Weekday.MONDAY;\n            } else {\n                weekday = refWeekday - 1;\n                weekday = modifier == \"last\" ? weekday - 1 : weekday + 1;\n                weekday = (weekday % 5) + 1;\n            }\n        } else {\n            return null;\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nconst PATTERN = new RegExp(\n    `(this|last|past|next|after\\\\s*this)\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)` + \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class ENRelativeDateFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"next\" || modifier.startsWith(\"after\")) {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = dayjs(context.reference.instant);\n\n        // This week\n        if (unitWord.match(/week/i)) {\n            date = date.add(-date.get(\"d\"), \"d\");\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.imply(\"year\", date.year());\n        }\n\n        // This month\n        else if (unitWord.match(/month/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            components.imply(\"day\", date.date());\n            components.assign(\"year\", date.year());\n            components.assign(\"month\", date.month() + 1);\n        }\n\n        // This year\n        else if (unitWord.match(/year/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            date = date.add(-date.month(), \"month\");\n\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.assign(\"year\", date.year());\n        }\n\n        return components;\n    }\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport { findMostLikelyADYear, findYearClosestToRef } from \"../../calculation/years\";\n\n/**\n * Date format with slash \"/\" (or dot \".\") between numbers.\n * For examples:\n * - 7/10\n * - 7/12/2020\n * - 7.12.2020\n */\nconst PATTERN = new RegExp(\n    \"([^\\\\d]|^)\" +\n        \"([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})\" +\n        \"(?:[\\\\/\\\\.\\\\-]([0-9]{4}|[0-9]{2}))?\" +\n        \"(\\\\W|$)\",\n    \"i\"\n);\n\nconst OPENING_GROUP = 1;\nconst ENDING_GROUP = 5;\n\nconst FIRST_NUMBERS_GROUP = 2;\nconst SECOND_NUMBERS_GROUP = 3;\n\nconst YEAR_GROUP = 4;\n\nexport default class SlashDateFormatParser implements Parser {\n    groupNumberMonth: number;\n    groupNumberDay: number;\n\n    constructor(littleEndian: boolean) {\n        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n    }\n\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        // Because of how pattern is executed on remaining text in `chrono.ts`, the character before the match could\n        // still be a number (e.g. X[X/YY/ZZ] or XX[/YY/ZZ] or [XX/YY/]ZZ). We want to check and skip them.\n        const index = match.index + match[OPENING_GROUP].length;\n        const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;\n        if (index > 0) {\n            const textBefore = context.text.substring(0, index);\n            if (textBefore.match(\"\\\\d/?$\")) {\n                return;\n            }\n        }\n        if (indexEnd < context.text.length) {\n            const textAfter = context.text.substring(indexEnd);\n            if (textAfter.match(\"^/?\\\\d\")) {\n                return;\n            }\n        }\n\n        const text = context.text.substring(index, indexEnd);\n\n        // '1.12', '1.12.12' is more like a version numbers\n        if (text.match(/^\\d\\.\\d$/) || text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}\\s*$/)) {\n            return;\n        }\n\n        // MM/dd -> OK\n        // MM.dd -> NG\n        if (!match[YEAR_GROUP] && text.indexOf(\"/\") < 0) {\n            return;\n        }\n\n        const result = context.createParsingResult(index, text);\n        let month = parseInt(match[this.groupNumberMonth]);\n        let day = parseInt(match[this.groupNumberDay]);\n        if (month < 1 || month > 12) {\n            if (month > 12) {\n                if (day >= 1 && day <= 12 && month <= 31) {\n                    [day, month] = [month, day];\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        result.start.assign(\"day\", day);\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const rawYearNumber = parseInt(match[YEAR_GROUP]);\n            const year = findMostLikelyADYear(rawYearNumber);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result.addTag(\"parser/SlashDateFormatParser\");\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nconst PATTERN = new RegExp(`(this|last|past|next|after|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\nconst PATTERN_NO_ABBR = new RegExp(\n    `(this|last|past|next|after|\\\\+|-)\\\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private allowAbbreviations: boolean = true) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.allowAbbreviations ? PATTERN : PATTERN_NO_ABBR;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const prefix = match[1].toLowerCase();\n        let timeUnits = parseTimeUnits(match[2]);\n        if (!timeUnits) {\n            return null;\n        }\n        switch (prefix) {\n            case \"last\":\n            case \"past\":\n            case \"-\":\n                timeUnits = reverseTimeUnits(timeUnits);\n                break;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseTimeUnits } from \"../constants\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nfunction IsPositiveFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^[+-]/i) != null;\n}\n\nfunction IsNegativeFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^-/i) != null;\n}\n\n/**\n * Merges a relative data/time that comes after an absolute date.\n * - [2020-02-13] [+2 weeks]\n * - [next tuesday] [+10 days]\n */\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        if (!textBetween.match(/^\\s*$/i)) {\n            return false;\n        }\n\n        return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult, context): ParsingResult {\n        let timeUnits = parseTimeUnits(nextResult.text);\n        if (IsNegativeFollowingReference(nextResult)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            new ReferenceWithTimezone(currentResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            currentResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseTimeUnits } from \"../constants\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(before|from)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(after|since)$/i) != null;\n}\n\n/**\n * Merges a relative data/time that follow by an absolute date.\n * - [2 weeks before] [2020-02-13]\n * - [2 days after] [next Friday]\n */\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let timeUnits = parseTimeUnits(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            new ReferenceWithTimezone(nextResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { ParsingContext, Refiner } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\n\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (!result.start.isDateWithUnknownYear()) {\n                return;\n            }\n\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            context.debug(() => {\n                console.log(`Extracting year: '${match[0]}' into : ${result}`);\n            });\n\n            const year = parseYear(match[YEAR_GROUP]);\n            if (result.end != null) {\n                result.end.assign(\"year\", year);\n            }\n            result.start.assign(\"year\", year);\n            result.text += match[0];\n        });\n\n        return results;\n    }\n}\n", "import { Filter } from \"../../../common/abstractRefiners\";\nimport { ParsingResult } from \"../../../results\";\n\nexport default class ENUnlikelyFormatFilter extends Filter {\n    constructor() {\n        super();\n    }\n\n    isValid(context, result: ParsingResult): boolean {\n        const text = result.text.trim();\n\n        // If the result is consists of the whole text (e.g. \"2024\", \"May\", etc),\n        // then it is unlikely to be a date.\n        if (text === context.text.trim()) {\n            return true;\n        }\n\n        // In English, the word \"may\" is a month name, but it is also a modal verb.\n        // Check if the text before \"may\" follows some allowed patterns.\n        if (text.toLowerCase() === \"may\") {\n            const textBefore = context.text.substring(0, result.index).trim();\n            if (!textBefore.match(/\\b(in)$/i)) {\n                context.debug(() => {\n                    console.log(`Removing unlikely result: ${result}`);\n                });\n\n                return false;\n            }\n        }\n\n        // In English, \"the second\" could refer to the ordinal number or timeunit.\n        if (text.toLowerCase().endsWith(\"the second\")) {\n            const textAfter = context.text.substring(result.index + result.text.length).trim();\n            if (textAfter.length > 0) {\n                context.debug(() => {\n                    console.log(`Removing unlikely result: ${result}`);\n                });\n            }\n            return false;\n        }\n\n        return true;\n    }\n}\n", "import { Configuration } from \"../../chrono\";\n\nimport ENTimeUnitWithinFormatParser from \"./parsers/ENTimeUnitWithinFormatParser\";\nimport ENMonthNameLittleEndianParser from \"./parsers/ENMonthNameLittleEndianParser\";\nimport ENMonthNameMiddleEndianParser from \"./parsers/ENMonthNameMiddleEndianParser\";\nimport ENMonthNameParser from \"./parsers/ENMonthNameParser\";\nimport ENYearMonthDayParser from \"./parsers/ENYearMonthDayParser\";\nimport ENSlashMonthFormatParser from \"./parsers/ENSlashMonthFormatParser\";\nimport ENTimeExpressionParser from \"./parsers/ENTimeExpressionParser\";\nimport ENTimeUnitAgoFormatParser from \"./parsers/ENTimeUnitAgoFormatParser\";\nimport ENTimeUnitLaterFormatParser from \"./parsers/ENTimeUnitLaterFormatParser\";\nimport ENMergeDateRangeRefiner from \"./refiners/ENMergeDateRangeRefiner\";\nimport ENMergeDateTimeRefiner from \"./refiners/ENMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport ENCasualDateParser from \"./parsers/ENCasualDateParser\";\nimport ENCasualTimeParser from \"./parsers/ENCasualTimeParser\";\nimport ENWeekdayParser from \"./parsers/ENWeekdayParser\";\nimport ENRelativeDateFormatParser from \"./parsers/ENRelativeDateFormatParser\";\n\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ENTimeUnitCasualRelativeFormatParser from \"./parsers/ENTimeUnitCasualRelativeFormatParser\";\nimport ENMergeRelativeAfterDateRefiner from \"./refiners/ENMergeRelativeAfterDateRefiner\";\nimport ENMergeRelativeFollowByDateRefiner from \"./refiners/ENMergeRelativeFollowByDateRefiner\";\nimport OverlapRemovalRefiner from \"../../common/refiners/OverlapRemovalRefiner\";\nimport ENExtractYearSuffixRefiner from \"./refiners/ENExtractYearSuffixRefiner\";\nimport ENUnlikelyFormatFilter from \"./refiners/ENUnlikelyFormatFilter\";\n\nexport default class ENDefaultConfiguration {\n    /**\n     * Create a default *casual* {@Link Configuration} for English chrono.\n     * It calls {@Link createConfiguration} and includes additional parsers.\n     */\n    createCasualConfiguration(littleEndian = false): Configuration {\n        const option = this.createConfiguration(false, littleEndian);\n        option.parsers.push(new ENCasualDateParser());\n        option.parsers.push(new ENCasualTimeParser());\n        option.parsers.push(new ENMonthNameParser());\n        option.parsers.push(new ENRelativeDateFormatParser());\n        option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());\n        option.refiners.push(new ENUnlikelyFormatFilter());\n        return option;\n    }\n\n    /**\n     * Create a default {@Link Configuration} for English chrono\n     *\n     * @param strictMode If the timeunit mentioning should be strict, not casual\n     * @param littleEndian If format should be date-first/littleEndian (e.g. en_UK), not month-first/middleEndian (e.g. en_US)\n     */\n    createConfiguration(strictMode = true, littleEndian = false): Configuration {\n        const options = includeCommonConfiguration(\n            {\n                parsers: [\n                    new SlashDateFormatParser(littleEndian),\n                    new ENTimeUnitWithinFormatParser(strictMode),\n                    new ENMonthNameLittleEndianParser(),\n                    new ENMonthNameMiddleEndianParser(/*shouldSkipYearLikeDate=*/ littleEndian),\n                    new ENWeekdayParser(),\n                    new ENSlashMonthFormatParser(),\n                    new ENTimeExpressionParser(strictMode),\n                    new ENTimeUnitAgoFormatParser(strictMode),\n                    new ENTimeUnitLaterFormatParser(strictMode),\n                ],\n                refiners: [new ENMergeDateTimeRefiner()],\n            },\n            strictMode\n        );\n        options.parsers.unshift(new ENYearMonthDayParser(/*strictMonthDateOrder=*/ strictMode));\n\n        // These relative-dates consideration should be done before other common refiners.\n        options.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());\n        options.refiners.unshift(new ENMergeRelativeAfterDateRefiner());\n        options.refiners.unshift(new OverlapRemovalRefiner());\n\n        // Re-apply the date time refiner again after the timezone refinement and exclusion in common refiners.\n        options.refiners.push(new ENMergeDateTimeRefiner());\n\n        // Extract year after merging date and time\n        options.refiners.push(new ENExtractYearSuffixRefiner());\n\n        // Keep the date range refiner at the end (after all other refinements).\n        options.refiners.push(new ENMergeDateRangeRefiner());\n        return options;\n    }\n}\n", "import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference } from \"./types\";\nimport { AsyncDebugBlock, DebugHandler } from \"./debugging\";\nimport ENDefaultConfiguration from \"./locales/en/configuration\";\n\n/**\n * Chrono configuration.\n * It is simply an ordered list of parsers and refiners\n */\nexport interface Configuration {\n    parsers: Parser[];\n    refiners: Refiner[];\n}\n\n/**\n * An abstraction for Chrono *Parser*.\n *\n * Each parser should recognize and handle a certain date format.\n * Chrono uses multiple parses (and refiners) together for parsing the input.\n *\n * The parser implementation must provide {@Link pattern | pattern()} for the date format.\n *\n * The {@Link extract | extract()} method is called with the pattern's *match*.\n * The matching and extracting is controlled and adjusted to avoid for overlapping results.\n */\nexport interface Parser {\n    pattern(context: ParsingContext): RegExp;\n    extract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n}\n\n/**\n * A abstraction for Chrono *Refiner*.\n *\n * Each refiner takes the list of results (from parsers or other refiners) and returns another list of results.\n * Chrono applies each refiner in order and return the output from the last refiner.\n */\nexport interface Refiner {\n    refine: (context: ParsingContext, results: ParsingResult[]) => ParsingResult[];\n}\n\n/**\n * The Chrono object.\n */\nexport class Chrono {\n    parsers: Array<Parser>;\n    refiners: Array<Refiner>;\n\n    defaultConfig = new ENDefaultConfiguration();\n\n    constructor(configuration?: Configuration) {\n        configuration = configuration || this.defaultConfig.createCasualConfiguration();\n        this.parsers = [...configuration.parsers];\n        this.refiners = [...configuration.refiners];\n    }\n\n    /**\n     * Create a shallow copy of the Chrono object with the same configuration (`parsers` and `refiners`)\n     */\n    clone(): Chrono {\n        return new Chrono({\n            parsers: [...this.parsers],\n            refiners: [...this.refiners],\n        });\n    }\n\n    /**\n     * A shortcut for calling {@Link parse | parse() } then transform the result into Javascript's Date object\n     * @return Date object created from the first parse result\n     */\n    parseDate(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): Date | null {\n        const results = this.parse(text, referenceDate, option);\n        return results.length > 0 ? results[0].start.date() : null;\n    }\n\n    parse(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n        const context = new ParsingContext(text, referenceDate, option);\n\n        let results = [];\n        this.parsers.forEach((parser) => {\n            const parsedResults = Chrono.executeParser(context, parser);\n            results = results.concat(parsedResults);\n        });\n\n        results.sort((a, b) => {\n            return a.index - b.index;\n        });\n\n        this.refiners.forEach(function (refiner) {\n            results = refiner.refine(context, results);\n        });\n\n        return results;\n    }\n\n    private static executeParser(context: ParsingContext, parser: Parser) {\n        const results = [];\n        const pattern = parser.pattern(context);\n\n        const originalText = context.text;\n        let remainingText = context.text;\n        let match = pattern.exec(remainingText);\n\n        while (match) {\n            // Calculate match index on the full text;\n            const index = match.index + originalText.length - remainingText.length;\n            match.index = index;\n\n            const result = parser.extract(context, match);\n            if (!result) {\n                // If fails, move on by 1\n                remainingText = originalText.substring(match.index + 1);\n                match = pattern.exec(remainingText);\n                continue;\n            }\n\n            let parsedResult: ParsingResult = null;\n            if (result instanceof ParsingResult) {\n                parsedResult = result;\n            } else if (result instanceof ParsingComponents) {\n                parsedResult = context.createParsingResult(match.index, match[0]);\n                parsedResult.start = result;\n            } else {\n                parsedResult = context.createParsingResult(match.index, match[0], result);\n            }\n\n            const parsedIndex = parsedResult.index;\n            const parsedText = parsedResult.text;\n            context.debug(() =>\n                console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`)\n            );\n\n            results.push(parsedResult);\n            remainingText = originalText.substring(parsedIndex + parsedText.length);\n            match = pattern.exec(remainingText);\n        }\n\n        return results;\n    }\n}\n\nexport class ParsingContext implements DebugHandler {\n    readonly text: string;\n    readonly option: ParsingOption;\n    readonly reference: ReferenceWithTimezone;\n\n    /**\n     * @deprecated. Use `reference.instant` instead.\n     */\n    readonly refDate: Date;\n\n    constructor(text: string, refDate?: ParsingReference | Date, option?: ParsingOption) {\n        this.text = text;\n        this.reference = new ReferenceWithTimezone(refDate);\n        this.option = option ?? {};\n\n        this.refDate = this.reference.instant;\n    }\n\n    createParsingComponents(components?: { [c in Component]?: number } | ParsingComponents): ParsingComponents {\n        if (components instanceof ParsingComponents) {\n            return components;\n        }\n\n        return new ParsingComponents(this.reference, components);\n    }\n\n    createParsingResult(\n        index: number,\n        textOrEndIndex: number | string,\n        startComponents?: { [c in Component]?: number } | ParsingComponents,\n        endComponents?: { [c in Component]?: number } | ParsingComponents\n    ): ParsingResult {\n        const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n\n        const start = startComponents ? this.createParsingComponents(startComponents) : null;\n        const end = endComponents ? this.createParsingComponents(endComponents) : null;\n\n        return new ParsingResult(this.reference, index, text, start, end);\n    }\n\n    debug(block: AsyncDebugBlock): void {\n        if (this.option.debug) {\n            if (this.option.debug instanceof Function) {\n                this.option.debug(block);\n            } else {\n                const handler: DebugHandler = <DebugHandler>this.option.debug;\n                handler.debug(block);\n            }\n        }\n    }\n}\n", "import { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ISOFormatParser from \"../../common/parsers/ISOFormatParser\";\nimport DETimeExpressionParser from \"./parsers/DETimeExpressionParser\";\nimport DEWeekdayParser from \"./parsers/DEWeekdayParser\";\nimport DESpecificTimeExpressionParser from \"./parsers/DESpecificTimeExpressionParser\";\nimport DEMergeDateRangeRefiner from \"./refiners/DEMergeDateRangeRefiner\";\nimport DEMergeDateTimeRefiner from \"./refiners/DEMergeDateTimeRefiner\";\nimport DECasualDateParser from \"./parsers/DECasualDateParser\";\nimport DECasualTimeParser from \"./parsers/DECasualTimeParser\";\nimport DEMonthNameLittleEndianParser from \"./parsers/DEMonthNameLittleEndianParser\";\nimport DETimeUnitRelativeFormatParser from \"./parsers/DETimeUnitRelativeFormatParser\";\nimport DETimeUnitWithinFormatParser from \"./parsers/DETimeUnitWithinFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new DECasualTimeParser());\n    option.parsers.unshift(new DECasualDateParser());\n    option.parsers.unshift(new DETimeUnitRelativeFormatParser());\n    return option;\n}\n\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new ISOFormatParser(),\n                new SlashDateFormatParser(littleEndian),\n                new DETimeExpressionParser(),\n                new DESpecificTimeExpressionParser(),\n                new DEMonthNameLittleEndianParser(),\n                new DEWeekdayParser(),\n                new DETimeUnitWithinFormatParser(),\n            ],\n            refiners: [new DEMergeDateRangeRefiner(), new DEMergeDateTimeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { ParsingComponents } from \"../../../results\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport default class DETimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:um|von)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|bis)\\\\s*\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        // This looks more like a year e.g. 2020\n        if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n            return null;\n        }\n\n        return super.extractPrimaryTimeComponents(context, match);\n    }\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { TimeUnits } from \"../../utils/timeunits\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"sonntag\": 0,\n    \"so\": 0,\n    \"montag\": 1,\n    \"mo\": 1,\n    \"dienstag\": 2,\n    \"di\": 2,\n    \"mittwoch\": 3,\n    \"mi\": 3,\n    \"donnerstag\": 4,\n    \"do\": 4,\n    \"freitag\": 5,\n    \"fr\": 5,\n    \"samstag\": 6,\n    \"sa\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"januar\": 1,\n    \"jänner\": 1,\n    \"janner\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"februar\": 2,\n    \"feber\": 2,\n    \"feb\": 2,\n    \"feb.\": 2,\n    \"märz\": 3,\n    \"maerz\": 3,\n    \"mär\": 3,\n    \"mär.\": 3,\n    \"mrz\": 3,\n    \"mrz.\": 3,\n    \"april\": 4,\n    \"apr\": 4,\n    \"apr.\": 4,\n    \"mai\": 5,\n    \"juni\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"juli\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"august\": 8,\n    \"aug\": 8,\n    \"aug.\": 8,\n    \"september\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"sept\": 9,\n    \"sept.\": 9,\n    \"oktober\": 10,\n    \"okt\": 10,\n    \"okt.\": 10,\n    \"november\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"dezember\": 12,\n    \"dez\": 12,\n    \"dez.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"eins\": 1,\n    \"eine\": 1,\n    \"einem\": 1,\n    \"einen\": 1,\n    \"einer\": 1,\n    \"zwei\": 2,\n    \"drei\": 3,\n    \"vier\": 4,\n    \"fünf\": 5,\n    \"fuenf\": 5,\n    \"sechs\": 6,\n    \"sieben\": 7,\n    \"acht\": 8,\n    \"neun\": 9,\n    \"zehn\": 10,\n    \"elf\": 11,\n    \"zwölf\": 12,\n    \"zwoelf\": 12,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    sek: \"second\",\n    sekunde: \"second\",\n    sekunden: \"second\",\n    min: \"minute\",\n    minute: \"minute\",\n    minuten: \"minute\",\n    h: \"hour\",\n    std: \"hour\",\n    stunde: \"hour\",\n    stunden: \"hour\",\n    tag: \"d\",\n    tage: \"d\",\n    tagen: \"d\",\n    woche: \"week\",\n    wochen: \"week\",\n    monat: \"month\",\n    monate: \"month\",\n    monaten: \"month\",\n    monats: \"month\",\n    quartal: \"quarter\",\n    quartals: \"quarter\",\n    quartale: \"quarter\",\n    quartalen: \"quarter\",\n    a: \"year\",\n    j: \"year\",\n    jr: \"year\",\n    jahr: \"year\",\n    jahre: \"year\",\n    jahren: \"year\",\n    jahres: \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|halb?|halbe?|einigen?|wenigen?|mehreren?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"ein\" || num === \"einer\" || num === \"einem\" || num === \"einen\" || num === \"eine\") {\n        return 1;\n    } else if (num.match(/wenigen/)) {\n        return 2;\n    } else if (num.match(/halb/) || num.match(/halben/)) {\n        return 0.5;\n    } else if (num.match(/einigen/)) {\n        return 3;\n    } else if (num.match(/mehreren/)) {\n        return 7;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\\\s*[vn]\\\\.?\\\\s*(?:C(?:hr)?|(?:u\\\\.?|d\\\\.?(?:\\\\s*g\\\\.?)?)?\\\\s*Z)\\\\.?|\\\\s*(?:u\\\\.?|d\\\\.?(?:\\\\s*g\\\\.)?)\\\\s*Z\\\\.?)?)`;\nexport function parseYear(match: string): number {\n    if (/v/i.test(match)) {\n        // v.Chr.\n        return -parseInt(match.replace(/[^0-9]+/gi, \"\"));\n    }\n\n    if (/n/i.test(match)) {\n        // n.Chr.\n        return parseInt(match.replace(/[^0-9]+/gi, \"\"));\n    }\n\n    if (/z/i.test(match)) {\n        // n.Chr. as \"uZ\" or \"dgZ\"\n        return parseInt(match.replace(/[^0-9]+/gi, \"\"));\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseTimeUnits(timeunitText): TimeUnits {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:a[mn]\\\\s*?)?\" +\n        \"(?:(diese[mn]|letzte[mn]|n(?:ä|ae)chste[mn])\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(diese|letzte|n(?:ä|ae)chste)\\\\s*woche)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst SUFFIX_GROUP = 3;\nconst WEEKDAY_GROUP = 2;\n\nexport default class DEWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const offset = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[SUFFIX_GROUP];\n\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord.match(/letzte/)) {\n            modifier = \"last\";\n        } else if (modifierWord.match(/chste/)) {\n            modifier = \"next\";\n        } else if (modifierWord.match(/diese/)) {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, offset, modifier);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\n\n/**\n * 8h10m00s\n * 8h10m00\n * 8h10\n * 8 Uhr\n * 8h10m00s Uhr\n * 8:10 Uhr\n */\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(^|\\\\s|T)\" +\n        \"(?:(?:um|von)\\\\s*)?\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s)?)?\" +\n        \"(?:\\\\s*Uhr)?\" +\n        \"(?:\\\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\\\s+der\\\\s+Nacht))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"^\\\\s*(\\\\-|\\\\–|\\\\~|\\\\〜|bis(?:\\\\s+um)?|\\\\?)\\\\s*\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s)?)?\" +\n        \"(?:\\\\s*Uhr)?\" +\n        \"(?:\\\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\\\s+der\\\\s+Nacht))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP = 5;\n\nexport default class DESpecificTimeExpressionParser implements Parser {\n    pattern(context): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult | null {\n        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));\n\n        // This looks more like a year e.g. 2020\n        if (result.text.match(/^\\d{4}$/)) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);\n        if (!result.start) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        const remainingText = context.text.substring(match.index + match[0].length);\n        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);\n        if (secondMatch) {\n            result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);\n            if (result.end) {\n                result.text += secondMatch[0];\n            }\n        }\n\n        return result;\n    }\n\n    private static extractTimeComponent(\n        extractingComponents: ParsingComponents,\n        match: RegExpMatchArray\n    ): ParsingComponents | null {\n        let hour = 0;\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        hour = parseInt(match[HOUR_GROUP]);\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();\n            if (ampm.match(/morgen|vormittag/)) {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm.match(/nachmittag|abend/)) {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n\n            if (ampm.match(/nacht/)) {\n                if (hour == 12) {\n                    meridiem = Meridiem.AM;\n                    hour = 0;\n                } else if (hour < 6) {\n                    meridiem = Meridiem.AM;\n                } else {\n                    meridiem = Meridiem.PM;\n                    hour += 12;\n                }\n            }\n        }\n\n        extractingComponents.assign(\"hour\", hour);\n        extractingComponents.assign(\"minute\", minute);\n        if (meridiem !== null) {\n            extractingComponents.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                extractingComponents.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                extractingComponents.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            extractingComponents.assign(\"second\", second);\n        }\n\n        return extractingComponents;\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class DEMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(bis(?:\\s*(?:am|zum))?|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class DEMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|um|am|,|-)?\\\\s*$\");\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, assignTheNextDay, implySimilarTime } from \"../../../utils/dayjs\";\nimport DECasualTimeParser from \"./DECasualTimeParser\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = new RegExp(\n    `(jetzt|heute|morgen|übermorgen|uebermorgen|gestern|vorgestern|letzte\\\\s*nacht)` +\n        `(?:\\\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst TIME_GROUP = 2;\n\nexport default class DECasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = dayjs(context.refDate);\n        const dateKeyword = (match[DATE_GROUP] || \"\").toLowerCase();\n        const timeKeyword = (match[TIME_GROUP] || \"\").toLowerCase();\n\n        let component = context.createParsingComponents();\n        switch (dateKeyword) {\n            case \"jetzt\":\n                component = references.now(context.reference);\n                break;\n\n            case \"heute\":\n                component = references.today(context.reference);\n                break;\n\n            case \"morgen\":\n                assignTheNextDay(component, targetDate);\n                break;\n\n            case \"übermorgen\":\n            case \"uebermorgen\":\n                targetDate = targetDate.add(1, \"day\");\n                assignTheNextDay(component, targetDate);\n                break;\n\n            case \"gestern\":\n                targetDate = targetDate.add(-1, \"day\");\n                assignSimilarDate(component, targetDate);\n                implySimilarTime(component, targetDate);\n                break;\n\n            case \"vorgestern\":\n                targetDate = targetDate.add(-2, \"day\");\n                assignSimilarDate(component, targetDate);\n                implySimilarTime(component, targetDate);\n                break;\n\n            default:\n                if (dateKeyword.match(/letzte\\s*nacht/)) {\n                    if (targetDate.hour() > 6) {\n                        targetDate = targetDate.add(-1, \"day\");\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n\n                break;\n        }\n\n        if (timeKeyword) {\n            component = DECasualTimeParser.extractTimeComponents(component, timeKeyword);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { implySimilarTime } from \"../../../utils/dayjs\";\nimport { addImpliedTimeUnits } from \"../../../utils/timeunits\";\n\nexport default class DECasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(diesen)?\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const targetDate = dayjs(context.refDate);\n        const timeKeywordPattern = match[2].toLowerCase();\n        const component = context.createParsingComponents();\n        implySimilarTime(component, targetDate);\n        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);\n    }\n\n    static extractTimeComponents(component: ParsingComponents, timeKeywordPattern: string): ParsingComponents {\n        switch (timeKeywordPattern) {\n            case \"morgen\":\n                component.imply(\"hour\", 6);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"vormittag\":\n                component.imply(\"hour\", 9);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"mittag\":\n            case \"mittags\":\n                component.imply(\"hour\", 12);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"nachmittag\":\n                component.imply(\"hour\", 15);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"abend\":\n                component.imply(\"hour\", 18);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"nacht\":\n                component.imply(\"hour\", 22);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"mitternacht\":\n                if (component.get(\"hour\") > 1) {\n                    component = addImpliedTimeUnits(component, { \"day\": 1 });\n                }\n\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n        }\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:am\\\\s*?)?\" +\n        \"(?:den\\\\s*?)?\" +\n        `([0-9]{1,2})\\\\.` +\n        `(?:\\\\s*(?:bis(?:\\\\s*(?:am|zum))?|\\\\-|\\\\–|\\\\s)\\\\s*([0-9]{1,2})\\\\.?)?\\\\s*` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:(?:-|/|,?\\\\s*)(${YEAR_PATTERN}(?![^\\\\s]\\\\d)))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class DEMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { NUMBER_PATTERN, parseNumberPattern, TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nexport default class DETimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(\n            `(?:\\\\s*((?:nächste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\\\s*)?` +\n                `(${NUMBER_PATTERN})?` +\n                `(?:\\\\s*(nächste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?` +\n                `\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`,\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const num = match[2] ? parseNumberPattern(match[2]) : 1;\n        const unit = TIME_UNIT_DICTIONARY[match[4].toLowerCase()];\n        let timeUnits = {};\n        timeUnits[unit] = num;\n\n        // Modifier\n        let modifier = match[1] || match[3] || \"\";\n        modifier = modifier.toLowerCase();\n        if (!modifier) {\n            return;\n        }\n\n        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class DETimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:in|für|während)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseTimeUnits(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for French support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport FRCasualDateParser from \"./parsers/FRCasualDateParser\";\nimport FRCasualTimeParser from \"./parsers/FRCasualTimeParser\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport FRTimeExpressionParser from \"./parsers/FRTimeExpressionParser\";\nimport FRMergeDateTimeRefiner from \"./refiners/FRMergeDateTimeRefiner\";\nimport FRMergeDateRangeRefiner from \"./refiners/FRMergeDateRangeRefiner\";\nimport FRWeekdayParser from \"./parsers/FRWeekdayParser\";\nimport FRSpecificTimeExpressionParser from \"./parsers/FRSpecificTimeExpressionParser\";\nimport FRMonthNameLittleEndianParser from \"./parsers/FRMonthNameLittleEndianParser\";\nimport FRTimeUnitAgoFormatParser from \"./parsers/FRTimeUnitAgoFormatParser\";\nimport FRTimeUnitWithinFormatParser from \"./parsers/FRTimeUnitWithinFormatParser\";\nimport FRTimeUnitRelativeFormatParser from \"./parsers/FRTimeUnitRelativeFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new FRCasualDateParser());\n    option.parsers.unshift(new FRCasualTimeParser());\n    option.parsers.unshift(new FRTimeUnitRelativeFormatParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new FRMonthNameLittleEndianParser(),\n                new FRTimeExpressionParser(),\n                new FRSpecificTimeExpressionParser(),\n                new FRTimeUnitAgoFormatParser(),\n                new FRTimeUnitWithinFormatParser(),\n                new FRWeekdayParser(),\n            ],\n            refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dayjs\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class FRCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(maintenant|aujourd'hui|demain|hier|cette\\s*nuit|la\\s*veille)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = dayjs(context.refDate);\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"maintenant\":\n                return references.now(context.reference);\n\n            case \"aujourd'hui\":\n                return references.today(context.reference);\n\n            case \"hier\":\n                return references.yesterday(context.reference);\n\n            case \"demain\":\n                return references.tomorrow(context.reference);\n\n            default:\n                if (lowerText.match(/cette\\s*nuit/)) {\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 22);\n                    component.imply(\"meridiem\", Meridiem.PM);\n                } else if (lowerText.match(/la\\s*veille/)) {\n                    targetDate = targetDate.add(-1, \"day\");\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class FRCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(cet?)?\\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const suffixLower = match[2].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (suffixLower) {\n            case \"après-midi\":\n            case \"aprem\":\n                component.imply(\"hour\", 14);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"soir\":\n                component.imply(\"hour\", 18);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"matin\":\n                component.imply(\"hour\", 8);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"a midi\":\n                component.imply(\"hour\", 12);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"à minuit\":\n                component.imply(\"hour\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { ParsingComponents } from \"../../../results\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport default class FRTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:[àa])\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|[àa]|\\\\?)\\\\s*\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        // This looks more like a year e.g. 2020\n        if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n            return null;\n        }\n\n        return super.extractPrimaryTimeComponents(context, match);\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class FRMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|à|a|au|vers|de|,|-)?\\\\s*$\");\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class FRMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(à|a|au|-)\\s*$/i;\n    }\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"dimanche\": 0,\n    \"dim\": 0,\n    \"lundi\": 1,\n    \"lun\": 1,\n    \"mardi\": 2,\n    \"mar\": 2,\n    \"mercredi\": 3,\n    \"mer\": 3,\n    \"jeudi\": 4,\n    \"jeu\": 4,\n    \"vendredi\": 5,\n    \"ven\": 5,\n    \"samedi\": 6,\n    \"sam\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"janvier\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"février\": 2,\n    \"fév\": 2,\n    \"fév.\": 2,\n    \"fevrier\": 2,\n    \"fev\": 2,\n    \"fev.\": 2,\n    \"mars\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"avril\": 4,\n    \"avr\": 4,\n    \"avr.\": 4,\n    \"mai\": 5,\n    \"juin\": 6,\n    \"jun\": 6,\n    \"juillet\": 7,\n    \"juil\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"août\": 8,\n    \"aout\": 8,\n    \"septembre\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"sept\": 9,\n    \"sept.\": 9,\n    \"octobre\": 10,\n    \"oct\": 10,\n    \"oct.\": 10,\n    \"novembre\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"décembre\": 12,\n    \"decembre\": 12,\n    \"dec\": 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"un\": 1,\n    \"deux\": 2,\n    \"trois\": 3,\n    \"quatre\": 4,\n    \"cinq\": 5,\n    \"six\": 6,\n    \"sept\": 7,\n    \"huit\": 8,\n    \"neuf\": 9,\n    \"dix\": 10,\n    \"onze\": 11,\n    \"douze\": 12,\n    \"treize\": 13,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    \"sec\": \"second\",\n    \"seconde\": \"second\",\n    \"secondes\": \"second\",\n    \"min\": \"minute\",\n    \"mins\": \"minute\",\n    \"minute\": \"minute\",\n    \"minutes\": \"minute\",\n    \"h\": \"hour\",\n    \"hr\": \"hour\",\n    \"hrs\": \"hour\",\n    \"heure\": \"hour\",\n    \"heures\": \"hour\",\n    \"jour\": \"d\",\n    \"jours\": \"d\",\n    \"semaine\": \"week\",\n    \"semaines\": \"week\",\n    \"mois\": \"month\",\n    \"trimestre\": \"quarter\",\n    \"trimestres\": \"quarter\",\n    \"ans\": \"year\",\n    \"année\": \"year\",\n    \"années\": \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|une?\\\\b|quelques?|demi-?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"une\" || num === \"un\") {\n        return 1;\n    } else if (num.match(/quelques?/)) {\n        return 3;\n    } else if (num.match(/demi-?/)) {\n        return 0.5;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    num = num.replace(/(?:er)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n// 88 p. Chr. n.\n// 234 AC\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s*(?:AC|AD|p\\\\.\\\\s*C(?:hr?)?\\\\.\\\\s*n\\\\.)|[1-2][0-9]{3}|[5-9][0-9])`;\nexport function parseYear(match: string): number {\n    if (/AC/i.test(match)) {\n        match = match.replace(/BC/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/AD/i.test(match) || /C/i.test(match)) {\n        match = match.replace(/[^\\d]+/i, \"\");\n        return parseInt(match);\n    }\n\n    let yearNumber = parseInt(match);\n    if (yearNumber < 100) {\n        if (yearNumber > 50) {\n            yearNumber = yearNumber + 1900;\n        } else {\n            yearNumber = yearNumber + 2000;\n        }\n    }\n\n    return yearNumber;\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseTimeUnits(timeunitText): { [c in OpUnitType | QUnitType]?: number } {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as { [c in OpUnitType | QUnitType]?: number };\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:(?:ce)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(dernier|prochain)\\\\s*)?\" +\n        \"(?=\\\\W|\\\\d|$)\",\n    \"i\"\n);\n\nconst WEEKDAY_GROUP = 1;\nconst POSTFIX_GROUP = 2;\n\nexport default class FRWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        if (weekday === undefined) {\n            return null;\n        }\n\n        let suffix = match[POSTFIX_GROUP];\n        suffix = suffix || \"\";\n        suffix = suffix.toLowerCase();\n\n        let modifier = null;\n        if (suffix == \"dernier\") {\n            modifier = \"last\";\n        } else if (suffix == \"prochain\") {\n            modifier = \"next\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\n\n/**\n * 8h10m00s\n * 8h10m00\n * 8h10\n */\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(^|\\\\s|T)\" +\n        \"(?:(?:[àa])\\\\s*)?\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s|:)?)?\" +\n        \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"^\\\\s*(\\\\-|\\\\–|\\\\~|\\\\〜|[àa]|\\\\?)\\\\s*\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s|:)?)?\" +\n        \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP = 5;\n\nexport default class FRSpecificTimeExpressionParser implements Parser {\n    pattern(context): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult | null {\n        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));\n\n        // This looks more like a year e.g. 2020\n        if (result.text.match(/^\\d{4}$/)) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);\n        if (!result.start) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        const remainingText = context.text.substring(match.index + match[0].length);\n        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);\n        if (secondMatch) {\n            result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);\n            if (result.end) {\n                result.text += secondMatch[0];\n            }\n        }\n\n        return result;\n    }\n\n    private static extractTimeComponent(\n        extractingComponents: ParsingComponents,\n        match: RegExpMatchArray\n    ): ParsingComponents | null {\n        let hour = 0;\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        hour = parseInt(match[HOUR_GROUP]);\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        extractingComponents.assign(\"hour\", hour);\n        extractingComponents.assign(\"minute\", minute);\n        if (meridiem !== null) {\n            extractingComponents.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                extractingComponents.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                extractingComponents.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            extractingComponents.assign(\"second\", second);\n        }\n\n        return extractingComponents;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:on\\\\s*?)?\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:\\\\s*(?:au|\\\\-|\\\\–|jusqu'au?|\\\\s)\\\\s*(${ORDINAL_NUMBER_PATTERN}))?` +\n        `(?:-|/|\\\\s*(?:de)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:(?:-|/|,?\\\\s*)(${YEAR_PATTERN}(?![^\\\\s]\\\\d)))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class FRMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        //console.log(match)\n\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nexport default class FRTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(`il y a\\\\s*(${TIME_UNITS_PATTERN})(?=(?:\\\\W|$))`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[1]);\n        const outputTimeUnits = reverseTimeUnits(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class FRTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:dans|en|pour|pendant|de)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseTimeUnits(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { NUMBER_PATTERN, parseNumberPattern, TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nexport default class FRTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(\n            `(?:les?|la|l'|du|des?)\\\\s*` +\n                `(${NUMBER_PATTERN})?` +\n                `(?:\\\\s*(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?))?` +\n                `\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})` +\n                `(?:\\\\s*(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?))?`,\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const num = match[1] ? parseNumberPattern(match[1]) : 1;\n        const unit = TIME_UNIT_DICTIONARY[match[3].toLowerCase()];\n        let timeUnits = {};\n        timeUnits[unit] = num;\n\n        // Modifier\n        let modifier = match[2] || match[4] || \"\";\n        modifier = modifier.toLowerCase();\n        if (!modifier) {\n            return;\n        }\n\n        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {\n            timeUnits = reverseTimeUnits(timeUnits);\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Japanese support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport JPStandardParser from \"./parsers/JPStandardParser\";\nimport JPMergeDateRangeRefiner from \"./refiners/JPMergeDateRangeRefiner\";\nimport JPCasualDateParser from \"./parsers/JPCasualDateParser\";\n\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new JPCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    return {\n        parsers: [new JPStandardParser()],\n        refiners: [new JPMergeDateRangeRefiner()],\n    };\n}\n", "/**\n * to-hankaku.js\n * convert to ascii code strings.\n *\n * @version 1.0.1\n * @author think49\n * @url https://gist.github.com/964592\n * @license http://www.opensource.org/licenses/mit-license.php (The MIT License)\n */\nexport function toHankaku(text) {\n    return String(text)\n        .replace(/\\u2019/g, \"\\u0027\")\n        .replace(/\\u201D/g, \"\\u0022\")\n        .replace(/\\u3000/g, \"\\u0020\")\n        .replace(/\\uFFE5/g, \"\\u00A5\")\n        .replace(\n            /[\\uFF01\\uFF03-\\uFF06\\uFF08\\uFF09\\uFF0C-\\uFF19\\uFF1C-\\uFF1F\\uFF21-\\uFF3B\\uFF3D\\uFF3F\\uFF41-\\uFF5B\\uFF5D\\uFF5E]/g,\n            alphaNum\n        );\n}\n\nfunction alphaNum(token) {\n    return String.fromCharCode(token.charCodeAt(0) - 65248);\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { toHankaku } from \"../constants\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\n\nimport dayjs from \"dayjs\";\n\nconst PATTERN =\n    /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\\s*)?([0-9０-９]{1,2})月\\s*([0-9０-９]{1,2})日/i;\nconst SPECIAL_YEAR_GROUP = 1;\nconst TYPICAL_YEAR_GROUP = 2;\nconst ERA_GROUP = 3;\nconst YEAR_NUMBER_GROUP = 4;\nconst MONTH_GROUP = 5;\nconst DAY_GROUP = 6;\n\nexport default class JPStandardParser implements Parser {\n    pattern() {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = parseInt(toHankaku(match[MONTH_GROUP]));\n        const day = parseInt(toHankaku(match[DAY_GROUP]));\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match(\"同|今|本\")) {\n            const moment = dayjs(context.refDate);\n            components.assign(\"year\", moment.year());\n        }\n\n        if (match[TYPICAL_YEAR_GROUP]) {\n            const yearNumText = match[YEAR_NUMBER_GROUP];\n\n            let year = yearNumText == \"元\" ? 1 : parseInt(toHankaku(yearNumText));\n            if (match[ERA_GROUP] == \"令和\") {\n                year += 2018;\n            } else if (match[ERA_GROUP] == \"平成\") {\n                year += 1988;\n            } else if (match[ERA_GROUP] == \"昭和\") {\n                year += 1925;\n            }\n\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        return components;\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Japanese connecting phases\n * - 水曜日[ー]日曜日\n * - 水曜日[から]日曜日\n */\nexport default class JPMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(から|ー|-|～|~)\\s*$/i;\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport dayjs from \"dayjs\";\nimport { Meridiem } from \"../../../types\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /今日|きょう|本日|ほんじつ|昨日|きのう|明日|あした|今夜|こんや|今夕|こんゆう|今晩|こんばん|今朝|けさ/i;\n\nfunction normalizeTextToKanji(text: string) {\n    switch (text) {\n        case \"きょう\":\n            return \"今日\";\n        case \"ほんじつ\":\n            return \"本日\";\n        case \"きのう\":\n            return \"昨日\";\n        case \"あした\":\n            return \"明日\";\n        case \"こんや\":\n            return \"今夜\";\n        case \"こんゆう\":\n            return \"今夕\";\n        case \"こんばん\":\n            return \"今晩\";\n        case \"けさ\":\n            return \"今朝\";\n        default:\n            return text;\n    }\n}\n\nexport default class JPCasualDateParser implements Parser {\n    pattern() {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const text = normalizeTextToKanji(match[0]);\n\n        const date = dayjs(context.refDate);\n        const components = context.createParsingComponents();\n\n        switch (text) {\n            case \"昨日\":\n                return references.yesterday(context.reference);\n\n            case \"明日\":\n                return references.tomorrow(context.reference);\n\n            case \"本日\":\n            case \"今日\":\n                return references.today(context.reference);\n        }\n\n        if (text == \"今夜\" || text == \"今夕\" || text == \"今晩\") {\n            components.imply(\"hour\", 22);\n            components.assign(\"meridiem\", Meridiem.PM);\n        } else if (text.match(\"今朝\")) {\n            components.imply(\"hour\", 6);\n            components.assign(\"meridiem\", Meridiem.AM);\n        }\n\n        components.assign(\"day\", date.date());\n        components.assign(\"month\", date.month() + 1);\n        components.assign(\"year\", date.year());\n        return components;\n    }\n}\n", "/**\n * Chrono components for Portuguese support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport PTWeekdayParser from \"./parsers/PTWeekdayParser\";\nimport PTTimeExpressionParser from \"./parsers/PTTimeExpressionParser\";\nimport PTMergeDateTimeRefiner from \"./refiners/PTMergeDateTimeRefiner\";\nimport PTMergeDateRangeRefiner from \"./refiners/PTMergeDateRangeRefiner\";\nimport PTMonthNameLittleEndianParser from \"./parsers/PTMonthNameLittleEndianParser\";\nimport PTCasualDateParser from \"./parsers/PTCasualDateParser\";\nimport PTCasualTimeParser from \"./parsers/PTCasualTimeParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.push(new PTCasualDateParser());\n    option.parsers.push(new PTCasualTimeParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new PTWeekdayParser(),\n                new PTTimeExpressionParser(),\n                new PTMonthNameLittleEndianParser(),\n            ],\n            refiners: [new PTMergeDateTimeRefiner(), new PTMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "export const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"domingo\": 0,\n    \"dom\": 0,\n    \"segunda\": 1,\n    \"segunda-feira\": 1,\n    \"seg\": 1,\n    \"terça\": 2,\n    \"terça-feira\": 2,\n    \"ter\": 2,\n    \"quarta\": 3,\n    \"quarta-feira\": 3,\n    \"qua\": 3,\n    \"quinta\": 4,\n    \"quinta-feira\": 4,\n    \"qui\": 4,\n    \"sexta\": 5,\n    \"sexta-feira\": 5,\n    \"sex\": 5,\n    \"sábado\": 6,\n    \"sabado\": 6,\n    \"sab\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"janeiro\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"fevereiro\": 2,\n    \"fev\": 2,\n    \"fev.\": 2,\n    \"março\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"abril\": 4,\n    \"abr\": 4,\n    \"abr.\": 4,\n    \"maio\": 5,\n    \"mai\": 5,\n    \"mai.\": 5,\n    \"junho\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"julho\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"agosto\": 8,\n    \"ago\": 8,\n    \"ago.\": 8,\n    \"setembro\": 9,\n    \"set\": 9,\n    \"set.\": 9,\n    \"outubro\": 10,\n    \"out\": 10,\n    \"out.\": 10,\n    \"novembro\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"dezembro\": 12,\n    \"dez\": 12,\n    \"dez.\": 12,\n};\n\n//-----------------------------\n// 88 p. Chr. n.\n// 234 AC\nexport const YEAR_PATTERN = \"[0-9]{1,4}(?![^\\\\s]\\\\d)(?:\\\\s*[a|d]\\\\.?\\\\s*c\\\\.?|\\\\s*a\\\\.?\\\\s*d\\\\.?)?\";\nexport function parseYear(match: string): number {\n    if (match.match(/^[0-9]{1,4}$/)) {\n        let yearNumber = parseInt(match);\n        if (yearNumber < 100) {\n            if (yearNumber > 50) {\n                yearNumber = yearNumber + 1900;\n            } else {\n                yearNumber = yearNumber + 2000;\n            }\n        }\n        return yearNumber;\n    }\n\n    if (match.match(/a\\.?\\s*c\\.?/i)) {\n        match = match.replace(/a\\.?\\s*c\\.?/i, \"\");\n        return -parseInt(match);\n    }\n\n    return parseInt(match);\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:(este|esta|passado|pr[oó]ximo)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(este|esta|passado|pr[óo]ximo)\\\\s*semana)?\" +\n        \"(?=\\\\W|\\\\d|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class PTWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        if (weekday === undefined) {\n            return null;\n        }\n\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let norm = prefix || postfix || \"\";\n        norm = norm.toLowerCase();\n\n        let modifier = null;\n        if (norm == \"passado\") {\n            modifier = \"this\";\n        } else if (norm == \"próximo\" || norm == \"proximo\") {\n            modifier = \"next\";\n        } else if (norm == \"este\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class PTTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:ao?|às?|das|da|de|do)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|a(?:o)?|\\\\?)\\\\s*\";\n    }\n\n    // extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n    //     // This looks more like a year e.g. 2020\n    //     // if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n    //     //     return null;\n    //     // }\n    //\n    //     return super.extractPrimaryTimeComponents(context, match);\n    // }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class PTMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(?:,|à)?\\\\s*$\");\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class PTMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(?:-)\\s*$/i;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `([0-9]{1,2})(?:º|ª|°)?` +\n        \"(?:\\\\s*(?:desde|de|\\\\-|\\\\–|ao?|\\\\s)\\\\s*([0-9]{1,2})(?:º|ª|°)?)?\\\\s*(?:de)?\\\\s*\" +\n        `(?:-|/|\\\\s*(?:de|,)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:\\\\s*(?:de|,)?\\\\s*(${YEAR_PATTERN}))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class PTMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class PTCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(agora|hoje|amanha|amanhã|ontem)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"agora\":\n                return references.now(context.reference);\n\n            case \"hoje\":\n                return references.today(context.reference);\n\n            case \"amanha\":\n            case \"amanhã\":\n                return references.tomorrow(context.reference);\n\n            case \"ontem\":\n                return references.yesterday(context.reference);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignTheNextDay } from \"../../../utils/dayjs\";\nimport dayjs from \"dayjs\";\n\nexport default class PTCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return /(?:esta\\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = dayjs(context.refDate);\n        const component = context.createParsingComponents();\n        switch (match[1].toLowerCase()) {\n            case \"tarde\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"noite\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 22);\n                break;\n\n            case \"manha\":\n            case \"manhã\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"meia-noite\":\n                assignTheNextDay(component, targetDate);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"meio-dia\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "/**\n * Chrono components for Dutch support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport NLMergeDateRangeRefiner from \"./refiners/NLMergeDateRangeRefiner\";\nimport NLMergeDateTimeRefiner from \"./refiners/NLMergeDateTimeRefiner\";\nimport NLCasualDateParser from \"./parsers/NLCasualDateParser\";\nimport NLCasualTimeParser from \"./parsers/NLCasualTimeParser\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport NLTimeUnitWithinFormatParser from \"./parsers/NLTimeUnitWithinFormatParser\";\nimport NLWeekdayParser from \"./parsers/NLWeekdayParser\";\nimport NLMonthNameMiddleEndianParser from \"./parsers/NLMonthNameMiddleEndianParser\";\nimport NLMonthNameParser from \"./parsers/NLMonthNameParser\";\nimport NLSlashMonthFormatParser from \"./parsers/NLSlashMonthFormatParser\";\nimport NLTimeExpressionParser from \"./parsers/NLTimeExpressionParser\";\nimport NLCasualYearMonthDayParser from \"./parsers/NLCasualYearMonthDayParser\";\nimport NLCasualDateTimeParser from \"./parsers/NLCasualDateTimeParser\";\nimport NLTimeUnitCasualRelativeFormatParser from \"./parsers/NLTimeUnitCasualRelativeFormatParser\";\nimport NLRelativeDateFormatParser from \"./parsers/NLRelativeDateFormatParser\";\nimport NLTimeUnitAgoFormatParser from \"./parsers/NLTimeUnitAgoFormatParser\";\nimport NLTimeUnitLaterFormatParser from \"./parsers/NLTimeUnitLaterFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new NLCasualDateParser());\n    option.parsers.unshift(new NLCasualTimeParser());\n    option.parsers.unshift(new NLCasualDateTimeParser());\n    option.parsers.unshift(new NLMonthNameParser());\n    option.parsers.unshift(new NLRelativeDateFormatParser());\n    option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new NLTimeUnitWithinFormatParser(),\n                new NLMonthNameMiddleEndianParser(),\n                new NLMonthNameParser(),\n                new NLWeekdayParser(),\n                new NLCasualYearMonthDayParser(),\n                new NLSlashMonthFormatParser(),\n                new NLTimeExpressionParser(strictMode),\n                new NLTimeUnitAgoFormatParser(strictMode),\n                new NLTimeUnitLaterFormatParser(strictMode),\n            ],\n            refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "/*\n\n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Dutch connecting phases\n * - 2020-02-13 [tot] 2020-02-13\n * - Wednesday [-] Friday\n */\nexport default class NLMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(tot|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide Dutch connecting phases\n * - 2020-02-13 [at] 6pm\n * - Tomorrow [after] 7am\n */\nexport default class NLMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(om|na|voor|in de|,|-)?\\\\s*$\");\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class NLCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(nu|vandaag|morgen|morgend|gisteren)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"nu\":\n                return references.now(context.reference);\n\n            case \"vandaag\":\n                return references.today(context.reference);\n\n            case \"morgen\":\n            case \"morgend\":\n                return references.tomorrow(context.reference);\n\n            case \"gisteren\":\n                return references.yesterday(context.reference);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport dayjs from \"dayjs\";\nimport { assignTheNextDay } from \"../../../utils/dayjs\";\n\nconst DAY_GROUP = 1;\nconst MOMENT_GROUP = 2;\n\nexport default class NLCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return /(deze)?\\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = dayjs(context.refDate);\n        const component = context.createParsingComponents();\n\n        if (match[DAY_GROUP] === \"deze\") {\n            component.assign(\"day\", context.refDate.getDate());\n            component.assign(\"month\", context.refDate.getMonth() + 1);\n            component.assign(\"year\", context.refDate.getFullYear());\n        }\n\n        switch (match[MOMENT_GROUP].toLowerCase()) {\n            case \"namiddag\":\n            case \"'s namiddags\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"avond\":\n            case \"'s avonds'\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 20);\n                break;\n\n            case \"middernacht\":\n                assignTheNextDay(component, targetDate);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"ochtend\":\n            case \"'s ochtends\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"middag\":\n            case \"'s middags\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { OpUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { TimeUnits } from \"../../utils/timeunits\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    // Zondag\n    zondag: 0,\n    zon: 0,\n    \"zon.\": 0,\n    zo: 0,\n    \"zo.\": 0,\n    // Maandag\n    maandag: 1,\n    ma: 1,\n    \"ma.\": 1,\n    // Dinsdag\n    dinsdag: 2,\n    din: 2,\n    \"din.\": 2,\n    di: 2,\n    \"di.\": 2,\n    // Woensdag\n    woensdag: 3,\n    woe: 3,\n    \"woe.\": 3,\n    wo: 3,\n    \"wo.\": 3,\n    // Donderdag\n    donderdag: 4,\n    dond: 4,\n    \"dond.\": 4,\n    do: 4,\n    \"do.\": 4,\n    // Vrijdag\n    vrijdag: 5,\n    vrij: 5,\n    \"vrij.\": 5,\n    vr: 5,\n    \"vr.\": 5,\n    // Zaterdag\n    zaterdag: 6,\n    zat: 6,\n    \"zat.\": 6,\n    \"za\": 6,\n    \"za.\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    januari: 1,\n    jan: 1,\n    \"jan.\": 1,\n    februari: 2,\n    feb: 2,\n    \"feb.\": 2,\n    maart: 3,\n    mar: 3,\n    \"mar.\": 3,\n    mrt: 3,\n    \"mrt.\": 3,\n    april: 4,\n    apr: 4,\n    \"apr.\": 4,\n    mei: 5,\n    juni: 6,\n    jun: 6,\n    \"jun.\": 6,\n    juli: 7,\n    jul: 7,\n    \"jul.\": 7,\n    augustus: 8,\n    aug: 8,\n    \"aug.\": 8,\n    september: 9,\n    sep: 9,\n    \"sep.\": 9,\n    sept: 9,\n    \"sept.\": 9,\n    oktober: 10,\n    okt: 10,\n    \"okt.\": 10,\n    november: 11,\n    nov: 11,\n    \"nov.\": 11,\n    december: 12,\n    dec: 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    een: 1,\n    twee: 2,\n    drie: 3,\n    vier: 4,\n    vijf: 5,\n    zes: 6,\n    zeven: 7,\n    acht: 8,\n    negen: 9,\n    tien: 10,\n    elf: 11,\n    twaalf: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    eerste: 1,\n    tweede: 2,\n    derde: 3,\n    vierde: 4,\n    vijfde: 5,\n    zesde: 6,\n    zevende: 7,\n    achtste: 8,\n    negende: 9,\n    tiende: 10,\n    elfde: 11,\n    twaalfde: 12,\n    dertiende: 13,\n    veertiende: 14,\n    vijftiende: 15,\n    zestiende: 16,\n    zeventiende: 17,\n    achttiende: 18,\n    negentiende: 19,\n    twintigste: 20,\n    \"eenentwintigste\": 21,\n    \"tweeëntwintigste\": 22,\n    \"drieentwintigste\": 23,\n    \"vierentwintigste\": 24,\n    \"vijfentwintigste\": 25,\n    \"zesentwintigste\": 26,\n    \"zevenentwintigste\": 27,\n    \"achtentwintig\": 28,\n    \"negenentwintig\": 29,\n    \"dertigste\": 30,\n    \"eenendertigste\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType } = {\n    sec: \"second\",\n    second: \"second\",\n    seconden: \"second\",\n    min: \"minute\",\n    mins: \"minute\",\n    minute: \"minute\",\n    minuut: \"minute\",\n    minuten: \"minute\",\n    minuutje: \"minute\",\n    h: \"hour\",\n    hr: \"hour\",\n    hrs: \"hour\",\n    uur: \"hour\",\n    u: \"hour\",\n    uren: \"hour\",\n    dag: \"d\",\n    dagen: \"d\",\n    week: \"week\",\n    weken: \"week\",\n    maand: \"month\",\n    maanden: \"month\",\n    jaar: \"year\",\n    jr: \"year\",\n    jaren: \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+[\\\\.,][0-9]+|halve?|half|paar)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"paar\") {\n        return 2;\n    } else if (num === \"half\" || num.match(/halve?/)) {\n        return 0.5;\n    }\n    // Replace \",\" with \".\" to support some European languages\n    return parseFloat(num.replace(\",\", \".\"));\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n    num = num.replace(/(?:ste|de)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;\nexport function parseYear(match: string): number {\n    if (/voor Christus/i.test(match)) {\n        // Before Christ\n        match = match.replace(/voor Christus/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/na Christus/i.test(match)) {\n        match = match.replace(/na Christus/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:binnen|in)\\\\s*)?`, SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseTimeUnits(timeunitText): TimeUnits {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class NLTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:binnen|in|binnen de|voor)\\\\s*` + \"(\" + TIME_UNITS_PATTERN + \")\" + `(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseTimeUnits(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../../nl/constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:op\\\\s*?)?\" +\n        \"(?:(deze|vorige|volgende)\\\\s*(?:week\\\\s*)?)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class NLWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"vorige\") {\n            modifier = \"last\";\n        } else if (modifierWord == \"volgende\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"deze\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:on\\\\s*?)?\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        \"(?:\\\\s*\" +\n        \"(?:tot|\\\\-|\\\\–|until|through|till|\\\\s)\\\\s*\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        \"(?:-|/|\\\\s*(?:of)?\\\\s*)\" +\n        \"(\" +\n        matchAnyPattern(MONTH_DICTIONARY) +\n        \")\" +\n        \"(?:\" +\n        \"(?:-|/|,?\\\\s*)\" +\n        `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 3;\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing BE/NL date format with month's name in full writing\n *  - 1 januari 2019\n *  - 01 januari 2019\n *  - 10 januari 2019\n *  - 13 januari\n *  - 10 - 25 maart\n *  - 10 - 25 maart 2019\n *  - 1 aug 2019\n *  - 1 september 200 voor Christus\n *  - 1 september 2002 na Christus\n *  - 19 januari 87\n *  - 12de juli 2013\n *  - 1ste november 2013\n */\nexport default class NLMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n", "import { MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * The parser for parsing month name and year.\n * - januari, 2012\n * - januari 2012\n * - januari\n */\nexport default class NLMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const components = context.createParsingComponents();\n        components.imply(\"day\", 1);\n\n        const monthName = match[MONTH_NAME_GROUP];\n        const month = MONTH_DICTIONARY[monthName.toLowerCase()];\n        components.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            components.imply(\"year\", year);\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\"([0-9]|0[1-9]|1[012])/([0-9]{4})\" + \"\", \"i\");\n\nconst MONTH_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * Month/Year date format with slash \"/\" (also \"-\" and \".\") between numbers\n * - 11/05\n * - 06/2005\n */\nexport default class NLSlashMonthFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const year = parseInt(match[YEAR_GROUP]);\n        const month = parseInt(match[MONTH_GROUP]);\n\n        return context.createParsingComponents().imply(\"day\", 1).assign(\"month\", month).assign(\"year\", year);\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { ParsingComponents } from \"../../../results\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport default class NLTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:om)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|om|\\\\?)\\\\s*\";\n    }\n\n    primarySuffix(): string {\n        return \"(?:\\\\s*(?:uur))?(?!/)(?=\\\\W|$)\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        // This looks more like a year e.g. 2020\n        if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n            return null;\n        }\n\n        return super.extractPrimaryTimeComponents(context, match);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class NLCasualYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            return null;\n        }\n\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        const day = parseInt(match[DATE_NUMBER_GROUP]);\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { Meridiem } from \"../../../types\";\nimport { assignSimilarDate, assignTheNextDay } from \"../../../utils/dayjs\";\nimport dayjs from \"dayjs\";\n\n/*\n * Find combined words\n * - morgenochtend\n * - morgenmiddag\n * - morgennamiddag\n * - morgenavond\n * - morgennacht\n * - vanochtend\n * - vanmiddag\n * - vannamiddag\n * - vanavond\n * - vannacht\n * - gisterenochtend\n * - gisterenmiddag\n * - gisterennamiddag\n * - gisterenavond\n * - gisterennacht\n * */\n\nconst DATE_GROUP = 1;\nconst TIME_OF_DAY_GROUP = 2;\n\nexport default class NLCasualDateTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const dateText = match[DATE_GROUP].toLowerCase();\n        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();\n        const component = context.createParsingComponents();\n        const targetDate = dayjs(context.refDate);\n\n        switch (dateText) {\n            case \"gisteren\":\n                assignSimilarDate(component, targetDate.add(-1, \"day\"));\n                break;\n            case \"van\":\n                assignSimilarDate(component, targetDate);\n                break;\n            case \"morgen\":\n                assignTheNextDay(component, targetDate);\n                break;\n        }\n\n        switch (timeText) {\n            case \"ochtend\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n            case \"middag\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n            case \"namiddag\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"avond\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 20);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nconst PATTERN = new RegExp(\n    `(dit|deze|vorig|afgelopen|(?:aan)?komend|over|\\\\+|-)e?\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PREFIX_WORD_GROUP = 1;\nconst TIME_UNIT_WORD_GROUP = 2;\n\nexport default class NLTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[PREFIX_WORD_GROUP].toLowerCase();\n        let timeUnits = parseTimeUnits(match[TIME_UNIT_WORD_GROUP]);\n        switch (prefix) {\n            case \"vorig\":\n            case \"afgelopen\":\n            case \"-\":\n                timeUnits = reverseTimeUnits(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nconst PATTERN = new RegExp(\n    `(dit|deze|(?:aan)?komend|volgend|afgelopen|vorig)e?\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class NLRelativeDateFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"volgend\" || modifier == \"komend\" || modifier == \"aankomend\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"afgelopen\" || modifier == \"vorig\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = dayjs(context.reference.instant);\n\n        // This week\n        if (unitWord.match(/week/i)) {\n            date = date.add(-date.get(\"d\"), \"d\");\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.imply(\"year\", date.year());\n        }\n\n        // This month\n        else if (unitWord.match(/maand/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            components.imply(\"day\", date.date());\n            components.assign(\"year\", date.year());\n            components.assign(\"month\", date.month() + 1);\n        }\n\n        // This year\n        else if (unitWord.match(/jaar/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            date = date.add(-date.month(), \"month\");\n\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.assign(\"year\", date.year());\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\n\nconst PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(?:geleden|voor|eerder)(?=(?:\\\\W|$))\", \"i\");\n\nconst STRICT_PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"geleden(?=(?:\\\\W|$))\", \"i\");\n\nexport default class NLTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[1]);\n        const outputTimeUnits = reverseTimeUnits(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(later|na|vanaf nu|voortaan|vooruit|uit)\" + \"(?=(?:\\\\W|$))\",\n    \"i\"\n);\n\nconst STRICT_PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(later|vanaf nu)\" + \"(?=(?:\\\\W|$))\", \"i\");\nconst GROUP_NUM_TIMEUNITS = 1;\n\nexport default class NLTimeUnitLaterFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const fragments = parseTimeUnits(match[GROUP_NUM_TIMEUNITS]);\n        return ParsingComponents.createRelativeFromReference(context.reference, fragments);\n    }\n}\n", "import { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport ExtractTimezoneOffsetRefiner from \"../../common/refiners/ExtractTimezoneOffsetRefiner\";\n\nimport ZHHansCasualDateParser from \"./hans/parsers/ZHHansCasualDateParser\";\nimport ZHHansDateParser from \"./hans/parsers/ZHHansDateParser\";\nimport ZHHansDeadlineFormatParser from \"./hans/parsers/ZHHansDeadlineFormatParser\";\nimport ZHHansRelationWeekdayParser from \"./hans/parsers/ZHHansRelationWeekdayParser\";\nimport ZHHansTimeExpressionParser from \"./hans/parsers/ZHHansTimeExpressionParser\";\nimport ZHHansWeekdayParser from \"./hans/parsers/ZHHansWeekdayParser\";\n\nimport ZHHantCasualDateParser from \"./hant/parsers/ZHHantCasualDateParser\";\nimport ZHHantDateParser from \"./hant/parsers/ZHHantDateParser\";\nimport ZHHantDeadlineFormatParser from \"./hant/parsers/ZHHantDeadlineFormatParser\";\nimport ZHHantRelationWeekdayParser from \"./hant/parsers/ZHHantRelationWeekdayParser\";\nimport ZHHantTimeExpressionParser from \"./hant/parsers/ZHHantTimeExpressionParser\";\nimport ZHHantWeekdayParser from \"./hant/parsers/ZHHantWeekdayParser\";\nimport ZHHantMergeDateRangeRefiner from \"./hant/refiners/ZHHantMergeDateRangeRefiner\";\nimport ZHHantMergeDateTimeRefiner from \"./hant/refiners/ZHHantMergeDateTimeRefiner\";\n\nexport * as hant from \"./hant\";\nexport * as hans from \"./hans\";\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new ZHHantCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    const configuration = includeCommonConfiguration({\n        parsers: [\n            new ZHHantDateParser(),\n            new ZHHansDateParser(),\n            new ZHHantRelationWeekdayParser(),\n            new ZHHansRelationWeekdayParser(),\n            new ZHHantWeekdayParser(),\n            new ZHHansWeekdayParser(),\n            new ZHHantTimeExpressionParser(),\n            new ZHHansTimeExpressionParser(),\n            new ZHHantDeadlineFormatParser(),\n            new ZHHansDeadlineFormatParser(),\n        ],\n        refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()],\n    });\n\n    // REMOVE ExtractTimezoneOffsetRefiner\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)\n    );\n\n    return configuration;\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber, zhStringToYear } from \"../constants\";\n\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\n\nexport default class ZHHansDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        // prettier-ignore\n        return new RegExp(\n            \"(\" +\n                \"\\\\d{2,4}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{4}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{2}\" +\n                \")?\" +\n                \"(?:\\\\s*)\" +\n                \"(?:年)?\" +\n                \"(?:[\\\\s|,|，]*)\" +\n                \"(\" +\n                \"\\\\d{1,2}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{1,3}\" +\n                \")\" +\n                \"(?:\\\\s*)\" +\n                \"(?:月)\" +\n                \"(?:\\\\s*)\" +\n                \"(\" +\n                \"\\\\d{1,2}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{1,3}\" +\n                \")?\" +\n                \"(?:\\\\s*)\" +\n                \"(?:日|号)?\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const startMoment = dayjs(context.refDate);\n        const result = context.createParsingResult(match.index, match[0]);\n\n        //Month\n        let month = parseInt(match[MONTH_GROUP]);\n        if (isNaN(month)) month = zhStringToNumber(match[MONTH_GROUP]);\n        result.start.assign(\"month\", month);\n\n        //Day\n        if (match[DAY_GROUP]) {\n            let day = parseInt(match[DAY_GROUP]);\n            if (isNaN(day)) day = zhStringToNumber(match[DAY_GROUP]);\n            result.start.assign(\"day\", day);\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n        }\n\n        //Year\n        if (match[YEAR_GROUP]) {\n            let year = parseInt(match[YEAR_GROUP]);\n            if (isNaN(year)) year = zhStringToYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        return result;\n    }\n}\n", "export const NUMBER = {\n    \"零\": 0,\n    \"〇\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"两\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n    \"七\": 7,\n    \"八\": 8,\n    \"九\": 9,\n    \"十\": 10,\n};\n\nexport const WEEKDAY_OFFSET = {\n    \"天\": 0,\n    \"日\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n};\n\nexport function zhStringToNumber(text: string) {\n    let number = 0;\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === \"十\") {\n            number = number === 0 ? NUMBER[char] : number * NUMBER[char];\n        } else {\n            number += NUMBER[char];\n        }\n    }\n\n    return number;\n}\n\nexport function zhStringToYear(text: string) {\n    let string = \"\";\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        string = string + NUMBER[char];\n    }\n\n    return parseInt(string);\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+|半|几)(?:\\\\s*)\" +\n        \"(?:个)?\" +\n        \"(秒(?:钟)?|分钟|小时|钟|日|天|星期|礼拜|月|年)\" +\n        \"(?:(?:之|过)?后|(?:之)?内)\",\n    \"i\"\n);\n\nconst NUMBER_GROUP = 1;\nconst UNIT_GROUP = 2;\n\nexport default class ZHHansDeadlineFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        let number = parseInt(match[NUMBER_GROUP]);\n        if (isNaN(number)) {\n            number = zhStringToNumber(match[NUMBER_GROUP]);\n        }\n\n        if (isNaN(number)) {\n            const string = match[NUMBER_GROUP];\n            if (string === \"几\") {\n                number = 3;\n            } else if (string === \"半\") {\n                number = 0.5;\n            } else {\n                //just in case\n                return null;\n            }\n        }\n\n        let date = dayjs(context.refDate);\n        const unit = match[UNIT_GROUP];\n        const unitAbbr = unit[0];\n\n        if (unitAbbr.match(/[日天星礼月年]/)) {\n            if (unitAbbr == \"日\" || unitAbbr == \"天\") {\n                date = date.add(number, \"d\");\n            } else if (unitAbbr == \"星\" || unitAbbr == \"礼\") {\n                date = date.add(number * 7, \"d\");\n            } else if (unitAbbr == \"月\") {\n                date = date.add(number, \"month\");\n            } else if (unitAbbr == \"年\") {\n                date = date.add(number, \"year\");\n            }\n\n            result.start.assign(\"year\", date.year());\n            result.start.assign(\"month\", date.month() + 1);\n            result.start.assign(\"day\", date.date());\n            return result;\n        }\n\n        if (unitAbbr == \"秒\") {\n            date = date.add(number, \"second\");\n        } else if (unitAbbr == \"分\") {\n            date = date.add(number, \"minute\");\n        } else if (unitAbbr == \"小\" || unitAbbr == \"钟\") {\n            date = date.add(number, \"hour\");\n        }\n\n        result.start.imply(\"year\", date.year());\n        result.start.imply(\"month\", date.month() + 1);\n        result.start.imply(\"day\", date.date());\n        result.start.assign(\"hour\", date.hour());\n        result.start.assign(\"minute\", date.minute());\n        result.start.assign(\"second\", date.second());\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(?<prefix>上|下|这)(?:个)?(?:星期|礼拜|周)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\"\n);\n\nexport default class ZHHansRelationWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let modifier = null;\n        const prefix = match.groups.prefix;\n\n        if (prefix == \"上\") {\n            modifier = \"last\";\n        } else if (prefix == \"下\") {\n            modifier = \"next\";\n        } else if (prefix == \"这\") {\n            modifier = \"this\";\n        }\n\n        let startMoment = dayjs(context.refDate);\n        let startMomentFixed = false;\n        const refOffset = startMoment.day();\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            startMoment = startMoment.day(offset - 7);\n            startMomentFixed = true;\n        } else if (modifier == \"next\") {\n            startMoment = startMoment.day(offset + 7);\n            startMomentFixed = true;\n        } else if (modifier == \"this\") {\n            startMoment = startMoment.day(offset);\n        } else {\n            if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {\n                startMoment = startMoment.day(offset - 7);\n            } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {\n                startMoment = startMoment.day(offset + 7);\n            } else {\n                startMoment = startMoment.day(offset);\n            }\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n            result.start.imply(\"month\", startMoment.month() + 1);\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(?:从|自)?\" +\n        \"(?:\" +\n        \"(今|明|前|大前|后|大后|昨)(早|朝|晚)|\" +\n        \"(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|后|大后|昨)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:点|时|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"(?:^\\\\s*(?:到|至|\\\\-|\\\\–|\\\\~|\\\\〜)\\\\s*)\" +\n        \"(?:\" +\n        \"(今|明|前|大前|后|大后|昨)(早|朝|晚)|\" +\n        \"(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|后|大后|昨)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:点|时|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst DAY_GROUP_1 = 1;\nconst ZH_AM_PM_HOUR_GROUP_1 = 2;\nconst ZH_AM_PM_HOUR_GROUP_2 = 3;\nconst DAY_GROUP_3 = 4;\nconst ZH_AM_PM_HOUR_GROUP_3 = 5;\nconst HOUR_GROUP = 6;\nconst MINUTE_GROUP = 7;\nconst SECOND_GROUP = 8;\nconst AM_PM_HOUR_GROUP = 9;\n\nexport default class ZHHansTimeExpressionParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // This pattern can be overlaped Ex. [12] AM, 1[2] AM\n        if (match.index > 0 && context.text[match.index - 1].match(/\\w/)) {\n            return null;\n        }\n\n        const refMoment = dayjs(context.refDate);\n        const result = context.createParsingResult(match.index, match[0]);\n        let startMoment = refMoment.clone();\n\n        // ----- Day\n        if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            if (day1 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    startMoment = startMoment.add(1, \"day\");\n                }\n            } else if (day1 == \"昨\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day1 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day1 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day1 == \"后\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day1 == \"大后\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n            if (day3 == \"明\") {\n                startMoment = startMoment.add(1, \"day\");\n            } else if (day3 == \"昨\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day3 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day3 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day3 == \"后\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day3 == \"大后\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n            result.start.imply(\"month\", startMoment.month() + 1);\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        let hour = 0;\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Second\n        if (match[SECOND_GROUP]) {\n            let second = parseInt(match[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(match[SECOND_GROUP]);\n            }\n            if (second >= 60) return null;\n            result.start.assign(\"second\", second);\n        }\n\n        hour = parseInt(match[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(match[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP]) {\n            if (match[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (match[MINUTE_GROUP] == \"正\" || match[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(match[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(match[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {\n            const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];\n            const zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {\n            const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];\n            const zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {\n            const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];\n            const zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.start.assign(\"hour\", hour);\n        result.start.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            result.start.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                result.start.imply(\"meridiem\", 0);\n            } else {\n                result.start.imply(\"meridiem\", 1);\n            }\n        }\n\n        // ==============================================================\n        //                  Extracting the 'to' chunk\n        // ==============================================================\n\n        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));\n        if (!match) {\n            // Not accept number only result\n            if (result.text.match(/^\\d+$/)) {\n                return null;\n            }\n            return result;\n        }\n\n        let endMoment = startMoment.clone();\n        result.end = context.createParsingComponents();\n\n        // ----- Day\n        if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            if (day1 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    endMoment = endMoment.add(1, \"day\");\n                }\n            } else if (day1 == \"昨\") {\n                endMoment = endMoment.add(-1, \"day\");\n            } else if (day1 == \"前\") {\n                endMoment = endMoment.add(-2, \"day\");\n            } else if (day1 == \"大前\") {\n                endMoment = endMoment.add(-3, \"day\");\n            } else if (day1 == \"后\") {\n                endMoment = endMoment.add(2, \"day\");\n            } else if (day1 == \"大后\") {\n                endMoment = endMoment.add(3, \"day\");\n            }\n            result.end.assign(\"day\", endMoment.date());\n            result.end.assign(\"month\", endMoment.month() + 1);\n            result.end.assign(\"year\", endMoment.year());\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n            if (day3 == \"明\") {\n                endMoment = endMoment.add(1, \"day\");\n            } else if (day3 == \"昨\") {\n                endMoment = endMoment.add(-1, \"day\");\n            } else if (day3 == \"前\") {\n                endMoment = endMoment.add(-2, \"day\");\n            } else if (day3 == \"大前\") {\n                endMoment = endMoment.add(-3, \"day\");\n            } else if (day3 == \"后\") {\n                endMoment = endMoment.add(2, \"day\");\n            } else if (day3 == \"大后\") {\n                endMoment = endMoment.add(3, \"day\");\n            }\n            result.end.assign(\"day\", endMoment.date());\n            result.end.assign(\"month\", endMoment.month() + 1);\n            result.end.assign(\"year\", endMoment.year());\n        } else {\n            result.end.imply(\"day\", endMoment.date());\n            result.end.imply(\"month\", endMoment.month() + 1);\n            result.end.imply(\"year\", endMoment.year());\n        }\n\n        hour = 0;\n        minute = 0;\n        meridiem = -1;\n\n        // ----- Second\n        if (match[SECOND_GROUP]) {\n            let second = parseInt(match[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(match[SECOND_GROUP]);\n            }\n\n            if (second >= 60) return null;\n            result.end.assign(\"second\", second);\n        }\n\n        hour = parseInt(match[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(match[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP]) {\n            if (match[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (match[MINUTE_GROUP] == \"正\" || match[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(match[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(match[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == 0) {\n                    result.start.imply(\"meridiem\", 0);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", 1);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {\n            const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];\n            const zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {\n            const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];\n            const zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {\n            const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];\n            const zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.text = result.text + match[0];\n        result.end.assign(\"hour\", hour);\n        result.end.assign(\"minute\", minute);\n        if (meridiem >= 0) {\n            result.end.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"meridiem\") == 1;\n            if (startAtPM && result.start.get(\"hour\") > hour) {\n                // 10pm - 1 (am)\n                result.end.imply(\"meridiem\", 0);\n            } else if (hour > 12) {\n                result.end.imply(\"meridiem\", 1);\n            }\n        }\n\n        if (result.end.date().getTime() < result.start.date().getTime()) {\n            result.end.imply(\"day\", result.end.get(\"day\") + 1);\n        }\n\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\"(?:星期|礼拜|周)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\");\n\nexport default class ZHHansWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let startMoment = dayjs(context.refDate);\n        const startMomentFixed = false;\n        const refOffset = startMoment.day();\n\n        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {\n            startMoment = startMoment.day(offset - 7);\n        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {\n            startMoment = startMoment.day(offset + 7);\n        } else {\n            startMoment = startMoment.day(offset);\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n            result.start.imply(\"month\", startMoment.month() + 1);\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingComponents, ParsingResult } from \"../../../../results\";\n\nconst NOW_GROUP = 1;\nconst DAY_GROUP_1 = 2;\nconst TIME_GROUP_1 = 3;\nconst TIME_GROUP_2 = 4;\nconst DAY_GROUP_3 = 5;\nconst TIME_GROUP_3 = 6;\n\nexport default class ZHHantCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(\n            \"(而家|立(?:刻|即)|即刻)|\" +\n                \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|\" +\n                \"(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n                \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)\" +\n                \"(?:[\\\\s|,|，]*)\" +\n                \"(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\",\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const index = match.index;\n        const result = context.createParsingResult(index, match[0]);\n\n        const refMoment = dayjs(context.refDate);\n        let startMoment = refMoment;\n\n        if (match[NOW_GROUP]) {\n            result.start.imply(\"hour\", refMoment.hour());\n            result.start.imply(\"minute\", refMoment.minute());\n            result.start.imply(\"second\", refMoment.second());\n            result.start.imply(\"millisecond\", refMoment.millisecond());\n        } else if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            const time1 = match[TIME_GROUP_1];\n\n            if (day1 == \"明\" || day1 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    startMoment = startMoment.add(1, \"day\");\n                }\n            } else if (day1 == \"昨\" || day1 == \"尋\" || day1 == \"琴\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day1 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day1 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day1 == \"後\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day1 == \"大後\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n\n            if (time1 == \"早\" || time1 == \"朝\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time1 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            }\n        } else if (match[TIME_GROUP_2]) {\n            const timeString2 = match[TIME_GROUP_2];\n            const time2 = timeString2[0];\n            if (time2 == \"早\" || time2 == \"朝\" || time2 == \"上\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time2 == \"下\" || time2 == \"晏\") {\n                result.start.imply(\"hour\", 15);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"中\") {\n                result.start.imply(\"hour\", 12);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"夜\" || time2 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"凌\") {\n                result.start.imply(\"hour\", 0);\n            }\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n\n            if (day3 == \"明\" || day3 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    startMoment = startMoment.add(1, \"day\");\n                }\n            } else if (day3 == \"昨\" || day3 == \"尋\" || day3 == \"琴\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day3 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day3 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day3 == \"後\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day3 == \"大後\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n\n            const timeString3 = match[TIME_GROUP_3];\n            if (timeString3) {\n                const time3 = timeString3[0];\n                if (time3 == \"早\" || time3 == \"朝\" || time3 == \"上\") {\n                    result.start.imply(\"hour\", 6);\n                } else if (time3 == \"下\" || time3 == \"晏\") {\n                    result.start.imply(\"hour\", 15);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"中\") {\n                    result.start.imply(\"hour\", 12);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"夜\" || time3 == \"晚\") {\n                    result.start.imply(\"hour\", 22);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"凌\") {\n                    result.start.imply(\"hour\", 0);\n                }\n            }\n        }\n\n        result.start.assign(\"day\", startMoment.date());\n        result.start.assign(\"month\", startMoment.month() + 1);\n        result.start.assign(\"year\", startMoment.year());\n\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber, zhStringToYear } from \"../constants\";\n\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\n\nexport default class ZHHantDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        // prettier-ignore\n        return new RegExp(\n            \"(\" +\n                \"\\\\d{2,4}|\" +\n                \"[\" + Object.keys(NUMBER).join(\"\") + \"]{4}|\" +\n                \"[\" + Object.keys(NUMBER).join(\"\") + \"]{2}\" +\n            \")?\"+\n            \"(?:\\\\s*)\" +\n            \"(?:年)?\" +\n            \"(?:[\\\\s|,|，]*)\" +\n\n            \"(\" +\n                \"\\\\d{1,2}|\"+\n                \"[\" +Object.keys(NUMBER).join(\"\") +\"]{1,2}\"+\n            \")\" +\n            \"(?:\\\\s*)\" +\n            \"(?:月)\" +\n            \"(?:\\\\s*)\" +\n            \"(\" + \n                \"\\\\d{1,2}|\" +\n                \"[\" + Object.keys(NUMBER).join(\"\") + \"]{1,2}\" +\n            \")?\" +\n            \"(?:\\\\s*)\" +\n            \"(?:日|號)?\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const startMoment = dayjs(context.refDate);\n        const result = context.createParsingResult(match.index, match[0]);\n\n        //Month\n        let month = parseInt(match[MONTH_GROUP]);\n        if (isNaN(month)) month = zhStringToNumber(match[MONTH_GROUP]);\n        result.start.assign(\"month\", month);\n\n        //Day\n        if (match[DAY_GROUP]) {\n            let day = parseInt(match[DAY_GROUP]);\n            if (isNaN(day)) day = zhStringToNumber(match[DAY_GROUP]);\n            result.start.assign(\"day\", day);\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n        }\n\n        //Year\n        if (match[YEAR_GROUP]) {\n            let year = parseInt(match[YEAR_GROUP]);\n            if (isNaN(year)) year = zhStringToYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        return result;\n    }\n}\n", "export const NUMBER = {\n    \"零\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"兩\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n    \"七\": 7,\n    \"八\": 8,\n    \"九\": 9,\n    \"十\": 10,\n    \"廿\": 20,\n    \"卅\": 30,\n};\n\nexport const WEEKDAY_OFFSET = {\n    \"天\": 0,\n    \"日\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n};\n\nexport function zhStringToNumber(text: string) {\n    let number = 0;\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === \"十\") {\n            number = number === 0 ? NUMBER[char] : number * NUMBER[char];\n        } else {\n            number += NUMBER[char];\n        }\n    }\n\n    return number;\n}\n\nexport function zhStringToYear(text: string) {\n    let string = \"\";\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        string = string + NUMBER[char];\n    }\n\n    return parseInt(string);\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+|半|幾)(?:\\\\s*)\" +\n        \"(?:個)?\" +\n        \"(秒(?:鐘)?|分鐘|小時|鐘|日|天|星期|禮拜|月|年)\" +\n        \"(?:(?:之|過)?後|(?:之)?內)\",\n    \"i\"\n);\n\nconst NUMBER_GROUP = 1;\nconst UNIT_GROUP = 2;\n\nexport default class ZHHantDeadlineFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        let number = parseInt(match[NUMBER_GROUP]);\n        if (isNaN(number)) {\n            number = zhStringToNumber(match[NUMBER_GROUP]);\n        }\n\n        if (isNaN(number)) {\n            const string = match[NUMBER_GROUP];\n            if (string === \"幾\") {\n                number = 3;\n            } else if (string === \"半\") {\n                number = 0.5;\n            } else {\n                //just in case\n                return null;\n            }\n        }\n\n        let date = dayjs(context.refDate);\n        const unit = match[UNIT_GROUP];\n        const unitAbbr = unit[0];\n\n        if (unitAbbr.match(/[日天星禮月年]/)) {\n            if (unitAbbr == \"日\" || unitAbbr == \"天\") {\n                date = date.add(number, \"d\");\n            } else if (unitAbbr == \"星\" || unitAbbr == \"禮\") {\n                date = date.add(number * 7, \"d\");\n            } else if (unitAbbr == \"月\") {\n                date = date.add(number, \"month\");\n            } else if (unitAbbr == \"年\") {\n                date = date.add(number, \"year\");\n            }\n\n            result.start.assign(\"year\", date.year());\n            result.start.assign(\"month\", date.month() + 1);\n            result.start.assign(\"day\", date.date());\n            return result;\n        }\n\n        if (unitAbbr == \"秒\") {\n            date = date.add(number, \"second\");\n        } else if (unitAbbr == \"分\") {\n            date = date.add(number, \"minute\");\n        } else if (unitAbbr == \"小\" || unitAbbr == \"鐘\") {\n            date = date.add(number, \"hour\");\n        }\n\n        result.start.imply(\"year\", date.year());\n        result.start.imply(\"month\", date.month() + 1);\n        result.start.imply(\"day\", date.date());\n        result.start.assign(\"hour\", date.hour());\n        result.start.assign(\"minute\", date.minute());\n        result.start.assign(\"second\", date.second());\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(?<prefix>上|今|下|這|呢)(?:個)?(?:星期|禮拜|週)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\"\n);\n\nexport default class ZHHantRelationWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let modifier = null;\n        const prefix = match.groups.prefix;\n\n        if (prefix == \"上\") {\n            modifier = \"last\";\n        } else if (prefix == \"下\") {\n            modifier = \"next\";\n        } else if (prefix == \"今\" || prefix == \"這\" || prefix == \"呢\") {\n            modifier = \"this\";\n        }\n\n        let startMoment = dayjs(context.refDate);\n        let startMomentFixed = false;\n        const refOffset = startMoment.day();\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            startMoment = startMoment.day(offset - 7);\n            startMomentFixed = true;\n        } else if (modifier == \"next\") {\n            startMoment = startMoment.day(offset + 7);\n            startMomentFixed = true;\n        } else if (modifier == \"this\") {\n            startMoment = startMoment.day(offset);\n        } else {\n            if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {\n                startMoment = startMoment.day(offset - 7);\n            } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {\n                startMoment = startMoment.day(offset + 7);\n            } else {\n                startMoment = startMoment.day(offset);\n            }\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n            result.start.imply(\"month\", startMoment.month() + 1);\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(?:由|從|自)?\" +\n        \"(?:\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|\" +\n        \"(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:點|時|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"(?:^\\\\s*(?:到|至|\\\\-|\\\\–|\\\\~|\\\\〜)\\\\s*)\" +\n        \"(?:\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|\" +\n        \"(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:點|時|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst DAY_GROUP_1 = 1;\nconst ZH_AM_PM_HOUR_GROUP_1 = 2;\nconst ZH_AM_PM_HOUR_GROUP_2 = 3;\nconst DAY_GROUP_3 = 4;\nconst ZH_AM_PM_HOUR_GROUP_3 = 5;\nconst HOUR_GROUP = 6;\nconst MINUTE_GROUP = 7;\nconst SECOND_GROUP = 8;\nconst AM_PM_HOUR_GROUP = 9;\n\nexport default class ZHHantTimeExpressionParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // This pattern can be overlaped Ex. [12] AM, 1[2] AM\n        if (match.index > 0 && context.text[match.index - 1].match(/\\w/)) {\n            return null;\n        }\n\n        const refMoment = dayjs(context.refDate);\n        const result = context.createParsingResult(match.index, match[0]);\n        let startMoment = refMoment.clone();\n\n        // ----- Day\n        if (match[DAY_GROUP_1]) {\n            var day1 = match[DAY_GROUP_1];\n            if (day1 == \"明\" || day1 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    startMoment = startMoment.add(1, \"day\");\n                }\n            } else if (day1 == \"昨\" || day1 == \"尋\" || day1 == \"琴\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day1 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day1 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day1 == \"後\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day1 == \"大後\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else if (match[DAY_GROUP_3]) {\n            var day3 = match[DAY_GROUP_3];\n            if (day3 == \"明\" || day3 == \"聽\") {\n                startMoment = startMoment.add(1, \"day\");\n            } else if (day3 == \"昨\" || day3 == \"尋\" || day3 == \"琴\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day3 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day3 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day3 == \"後\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day3 == \"大後\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n            result.start.imply(\"month\", startMoment.month() + 1);\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        let hour = 0;\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Second\n        if (match[SECOND_GROUP]) {\n            var second = parseInt(match[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(match[SECOND_GROUP]);\n            }\n            if (second >= 60) return null;\n            result.start.assign(\"second\", second);\n        }\n\n        hour = parseInt(match[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(match[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP]) {\n            if (match[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (match[MINUTE_GROUP] == \"正\" || match[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(match[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(match[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {\n            var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];\n            var zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"朝\" || zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {\n            var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];\n            var zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"朝\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晏\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {\n            var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];\n            var zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"朝\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晏\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.start.assign(\"hour\", hour);\n        result.start.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            result.start.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                result.start.imply(\"meridiem\", 0);\n            } else {\n                result.start.imply(\"meridiem\", 1);\n            }\n        }\n\n        // ==============================================================\n        //                  Extracting the 'to' chunk\n        // ==============================================================\n\n        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));\n        if (!match) {\n            // Not accept number only result\n            if (result.text.match(/^\\d+$/)) {\n                return null;\n            }\n            return result;\n        }\n\n        let endMoment = startMoment.clone();\n        result.end = context.createParsingComponents();\n\n        // ----- Day\n        if (match[DAY_GROUP_1]) {\n            var day1 = match[DAY_GROUP_1];\n            if (day1 == \"明\" || day1 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    endMoment = endMoment.add(1, \"day\");\n                }\n            } else if (day1 == \"昨\" || day1 == \"尋\" || day1 == \"琴\") {\n                endMoment = endMoment.add(-1, \"day\");\n            } else if (day1 == \"前\") {\n                endMoment = endMoment.add(-2, \"day\");\n            } else if (day1 == \"大前\") {\n                endMoment = endMoment.add(-3, \"day\");\n            } else if (day1 == \"後\") {\n                endMoment = endMoment.add(2, \"day\");\n            } else if (day1 == \"大後\") {\n                endMoment = endMoment.add(3, \"day\");\n            }\n            result.end.assign(\"day\", endMoment.date());\n            result.end.assign(\"month\", endMoment.month() + 1);\n            result.end.assign(\"year\", endMoment.year());\n        } else if (match[DAY_GROUP_3]) {\n            var day3 = match[DAY_GROUP_3];\n            if (day3 == \"明\" || day3 == \"聽\") {\n                endMoment = endMoment.add(1, \"day\");\n            } else if (day3 == \"昨\" || day3 == \"尋\" || day3 == \"琴\") {\n                endMoment = endMoment.add(-1, \"day\");\n            } else if (day3 == \"前\") {\n                endMoment = endMoment.add(-2, \"day\");\n            } else if (day3 == \"大前\") {\n                endMoment = endMoment.add(-3, \"day\");\n            } else if (day3 == \"後\") {\n                endMoment = endMoment.add(2, \"day\");\n            } else if (day3 == \"大後\") {\n                endMoment = endMoment.add(3, \"day\");\n            }\n            result.end.assign(\"day\", endMoment.date());\n            result.end.assign(\"month\", endMoment.month() + 1);\n            result.end.assign(\"year\", endMoment.year());\n        } else {\n            result.end.imply(\"day\", endMoment.date());\n            result.end.imply(\"month\", endMoment.month() + 1);\n            result.end.imply(\"year\", endMoment.year());\n        }\n\n        hour = 0;\n        minute = 0;\n        meridiem = -1;\n\n        // ----- Second\n        if (match[SECOND_GROUP]) {\n            var second = parseInt(match[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(match[SECOND_GROUP]);\n            }\n\n            if (second >= 60) return null;\n            result.end.assign(\"second\", second);\n        }\n\n        hour = parseInt(match[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(match[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP]) {\n            if (match[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (match[MINUTE_GROUP] == \"正\" || match[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(match[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(match[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == 0) {\n                    result.start.imply(\"meridiem\", 0);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", 1);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {\n            var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];\n            var zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"朝\" || zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {\n            var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];\n            var zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"朝\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晏\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {\n            var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];\n            var zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"朝\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晏\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.text = result.text + match[0];\n        result.end.assign(\"hour\", hour);\n        result.end.assign(\"minute\", minute);\n        if (meridiem >= 0) {\n            result.end.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"meridiem\") == 1;\n            if (startAtPM && result.start.get(\"hour\") > hour) {\n                // 10pm - 1 (am)\n                result.end.imply(\"meridiem\", 0);\n            } else if (hour > 12) {\n                result.end.imply(\"meridiem\", 1);\n            }\n        }\n\n        if (result.end.date().getTime() < result.start.date().getTime()) {\n            result.end.imply(\"day\", result.end.get(\"day\") + 1);\n        }\n\n        return result;\n    }\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\"(?:星期|禮拜|週)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\");\n\nexport default class ZHHantWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let startMoment = dayjs(context.refDate);\n        const startMomentFixed = false;\n        const refOffset = startMoment.day();\n\n        if (Math.abs(offset - 7 - refOffset) < Math.abs(offset - refOffset)) {\n            startMoment = startMoment.day(offset - 7);\n        } else if (Math.abs(offset + 7 - refOffset) < Math.abs(offset - refOffset)) {\n            startMoment = startMoment.day(offset + 7);\n        } else {\n            startMoment = startMoment.day(offset);\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", startMoment.date());\n            result.start.assign(\"month\", startMoment.month() + 1);\n            result.start.assign(\"year\", startMoment.year());\n        } else {\n            result.start.imply(\"day\", startMoment.date());\n            result.start.imply(\"month\", startMoment.month() + 1);\n            result.start.imply(\"year\", startMoment.year());\n        }\n\n        return result;\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\nexport default class ZHHantMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(至|到|\\-|\\~|～|－|ー)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\nexport default class ZHHantMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n}\n", "/**\n * Chrono components for zh support\n * TODO: Complete general zh support (current support only zh-Hant)\n */\n\nimport ExtractTimezoneOffsetRefiner from \"../../../common/refiners/ExtractTimezoneOffsetRefiner\";\nimport { includeCommonConfiguration } from \"../../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../../types\";\nimport ZHHantCasualDateParser from \"./parsers/ZHHantCasualDateParser\";\nimport ZHHantDateParser from \"./parsers/ZHHantDateParser\";\nimport ZHHantDeadlineFormatParser from \"./parsers/ZHHantDeadlineFormatParser\";\nimport ZHHantRelationWeekdayParser from \"./parsers/ZHHantRelationWeekdayParser\";\nimport ZHHantTimeExpressionParser from \"./parsers/ZHHantTimeExpressionParser\";\nimport ZHHantWeekdayParser from \"./parsers/ZHHantWeekdayParser\";\nimport ZHHantMergeDateRangeRefiner from \"./refiners/ZHHantMergeDateRangeRefiner\";\nimport ZHHantMergeDateTimeRefiner from \"./refiners/ZHHantMergeDateTimeRefiner\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const hant = new Chrono(createCasualConfiguration());\n\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new ZHHantCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    const configuration = includeCommonConfiguration({\n        parsers: [\n            new ZHHantDateParser(),\n            new ZHHantRelationWeekdayParser(),\n            new ZHHantWeekdayParser(),\n            new ZHHantTimeExpressionParser(),\n            new ZHHantDeadlineFormatParser(),\n        ],\n        refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()],\n    });\n\n    // REMOVE ExtractTimezoneOffsetRefiner\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)\n    );\n\n    return configuration;\n}\n", "/**\n * Chrono components for zh support\n */\n\nimport ExtractTimezoneOffsetRefiner from \"../../../common/refiners/ExtractTimezoneOffsetRefiner\";\nimport { includeCommonConfiguration } from \"../../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../../types\";\nimport ZHHansCasualDateParser from \"./parsers/ZHHansCasualDateParser\";\nimport ZHHansDateParser from \"./parsers/ZHHansDateParser\";\nimport ZHHansDeadlineFormatParser from \"./parsers/ZHHansDeadlineFormatParser\";\nimport ZHHansRelationWeekdayParser from \"./parsers/ZHHansRelationWeekdayParser\";\nimport ZHHansTimeExpressionParser from \"./parsers/ZHHansTimeExpressionParser\";\nimport ZHHansWeekdayParser from \"./parsers/ZHHansWeekdayParser\";\nimport ZHHansMergeDateRangeRefiner from \"./refiners/ZHHansMergeDateRangeRefiner\";\nimport ZHHansMergeDateTimeRefiner from \"./refiners/ZHHansMergeDateTimeRefiner\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const hans = new Chrono(createCasualConfiguration());\n\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new ZHHansCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    const configuration = includeCommonConfiguration({\n        parsers: [\n            new ZHHansDateParser(),\n            new ZHHansRelationWeekdayParser(),\n            new ZHHansWeekdayParser(),\n            new ZHHansTimeExpressionParser(),\n            new ZHHansDeadlineFormatParser(),\n        ],\n        refiners: [new ZHHansMergeDateRangeRefiner(), new ZHHansMergeDateTimeRefiner()],\n    });\n\n    // REMOVE ExtractTimezoneOffsetRefiner\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)\n    );\n\n    return configuration;\n}\n", "import dayjs from \"dayjs\";\nimport { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingComponents, ParsingResult } from \"../../../../results\";\n\nconst NOW_GROUP = 1;\nconst DAY_GROUP_1 = 2;\nconst TIME_GROUP_1 = 3;\nconst TIME_GROUP_2 = 4;\nconst DAY_GROUP_3 = 5;\nconst TIME_GROUP_3 = 6;\n\nexport default class ZHHansCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(\n            \"(现在|立(?:刻|即)|即刻)|\" +\n                \"(今|明|前|大前|后|大后|昨)(早|晚)|\" +\n                \"(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n                \"(今|明|前|大前|后|大后|昨)(?:日|天)\" +\n                \"(?:[\\\\s|,|，]*)\" +\n                \"(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\",\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const index = match.index;\n        const result = context.createParsingResult(index, match[0]);\n\n        const refMoment = dayjs(context.refDate);\n        let startMoment = refMoment;\n\n        if (match[NOW_GROUP]) {\n            result.start.imply(\"hour\", refMoment.hour());\n            result.start.imply(\"minute\", refMoment.minute());\n            result.start.imply(\"second\", refMoment.second());\n            result.start.imply(\"millisecond\", refMoment.millisecond());\n        } else if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            const time1 = match[TIME_GROUP_1];\n\n            if (day1 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    startMoment = startMoment.add(1, \"day\");\n                }\n            } else if (day1 == \"昨\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day1 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day1 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day1 == \"后\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day1 == \"大后\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n\n            if (time1 == \"早\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time1 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            }\n        } else if (match[TIME_GROUP_2]) {\n            const timeString2 = match[TIME_GROUP_2];\n            const time2 = timeString2[0];\n            if (time2 == \"早\" || time2 == \"上\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time2 == \"下\") {\n                result.start.imply(\"hour\", 15);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"中\") {\n                result.start.imply(\"hour\", 12);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"夜\" || time2 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"凌\") {\n                result.start.imply(\"hour\", 0);\n            }\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n\n            if (day3 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (refMoment.hour() > 1) {\n                    startMoment = startMoment.add(1, \"day\");\n                }\n            } else if (day3 == \"昨\") {\n                startMoment = startMoment.add(-1, \"day\");\n            } else if (day3 == \"前\") {\n                startMoment = startMoment.add(-2, \"day\");\n            } else if (day3 == \"大前\") {\n                startMoment = startMoment.add(-3, \"day\");\n            } else if (day3 == \"后\") {\n                startMoment = startMoment.add(2, \"day\");\n            } else if (day3 == \"大后\") {\n                startMoment = startMoment.add(3, \"day\");\n            }\n\n            const timeString3 = match[TIME_GROUP_3];\n            if (timeString3) {\n                const time3 = timeString3[0];\n                if (time3 == \"早\" || time3 == \"上\") {\n                    result.start.imply(\"hour\", 6);\n                } else if (time3 == \"下\") {\n                    result.start.imply(\"hour\", 15);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"中\") {\n                    result.start.imply(\"hour\", 12);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"夜\" || time3 == \"晚\") {\n                    result.start.imply(\"hour\", 22);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"凌\") {\n                    result.start.imply(\"hour\", 0);\n                }\n            }\n        }\n\n        result.start.assign(\"day\", startMoment.date());\n        result.start.assign(\"month\", startMoment.month() + 1);\n        result.start.assign(\"year\", startMoment.year());\n\n        return result;\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\nexport default class ZHHansMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(至|到|-|~|～|－|ー)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\nexport default class ZHHansMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n}\n", "/**\n * Chrono components for Russian support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport RUTimeUnitWithinFormatParser from \"./parsers/RUTimeUnitWithinFormatParser\";\nimport RUMonthNameLittleEndianParser from \"./parsers/RUMonthNameLittleEndianParser\";\nimport RUMonthNameParser from \"./parsers/RUMonthNameParser\";\nimport RUTimeExpressionParser from \"./parsers/RUTimeExpressionParser\";\nimport RUTimeUnitAgoFormatParser from \"./parsers/RUTimeUnitAgoFormatParser\";\nimport RUMergeDateRangeRefiner from \"./refiners/RUMergeDateRangeRefiner\";\nimport RUMergeDateTimeRefiner from \"./refiners/RUMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport RUCasualDateParser from \"./parsers/RUCasualDateParser\";\nimport RUCasualTimeParser from \"./parsers/RUCasualTimeParser\";\nimport RUWeekdayParser from \"./parsers/RUWeekdayParser\";\nimport RURelativeDateFormatParser from \"./parsers/RURelativeDateFormatParser\";\n\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport RUTimeUnitCasualRelativeFormatParser from \"./parsers/RUTimeUnitCasualRelativeFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n/**\n * Chrono object configured for parsing *casual* Russian\n */\nexport const casual = new Chrono(createCasualConfiguration());\n\n/**\n * Chrono object configured for parsing *strict* Russian\n */\nexport const strict = new Chrono(createConfiguration(true));\n\n/**\n * A shortcut for ru.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for ru.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * Create a default *casual* {@Link Configuration} for Russian chrono.\n * It calls {@Link createConfiguration} and includes additional parsers.\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration(false);\n    option.parsers.unshift(new RUCasualDateParser());\n    option.parsers.unshift(new RUCasualTimeParser());\n    option.parsers.unshift(new RUMonthNameParser());\n    option.parsers.unshift(new RURelativeDateFormatParser());\n    option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * Create a default {@Link Configuration} for Russian chrono\n *\n * @param strictMode If the timeunit mentioning should be strict, not casual\n */\nexport function createConfiguration(strictMode = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(true),\n                new RUTimeUnitWithinFormatParser(),\n                new RUMonthNameLittleEndianParser(),\n                new RUWeekdayParser(),\n                new RUTimeExpressionParser(strictMode),\n                new RUTimeUnitAgoFormatParser(),\n            ],\n            refiners: [new RUMergeDateTimeRefiner(), new RUMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { TimeUnits } from \"../../utils/timeunits\";\n\nexport const REGEX_PARTS = {\n    leftBoundary: \"([^\\\\p{L}\\\\p{N}_]|^)\",\n    rightBoundary: \"(?=[^\\\\p{L}\\\\p{N}_]|$)\",\n    flags: \"iu\",\n};\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    воскресенье: 0,\n    воскресенья: 0,\n    вск: 0,\n    \"вск.\": 0,\n    понедельник: 1,\n    понедельника: 1,\n    пн: 1,\n    \"пн.\": 1,\n    вторник: 2,\n    вторника: 2,\n    вт: 2,\n    \"вт.\": 2,\n    среда: 3,\n    среды: 3,\n    среду: 3,\n    ср: 3,\n    \"ср.\": 3,\n    четверг: 4,\n    четверга: 4,\n    чт: 4,\n    \"чт.\": 4,\n    пятница: 5,\n    пятницу: 5,\n    пятницы: 5,\n    пт: 5,\n    \"пт.\": 5,\n    суббота: 6,\n    субботу: 6,\n    субботы: 6,\n    сб: 6,\n    \"сб.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    январь: 1,\n    января: 1,\n    январе: 1,\n    февраль: 2,\n    февраля: 2,\n    феврале: 2,\n    март: 3,\n    марта: 3,\n    марте: 3,\n    апрель: 4,\n    апреля: 4,\n    апреле: 4,\n    май: 5,\n    мая: 5,\n    мае: 5,\n    июнь: 6,\n    июня: 6,\n    июне: 6,\n    июль: 7,\n    июля: 7,\n    июле: 7,\n    август: 8,\n    августа: 8,\n    августе: 8,\n    сентябрь: 9,\n    сентября: 9,\n    сентябре: 9,\n    октябрь: 10,\n    октября: 10,\n    октябре: 10,\n    ноябрь: 11,\n    ноября: 11,\n    ноябре: 11,\n    декабрь: 12,\n    декабря: 12,\n    декабре: 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    янв: 1,\n    \"янв.\": 1,\n    фев: 2,\n    \"фев.\": 2,\n    мар: 3,\n    \"мар.\": 3,\n    апр: 4,\n    \"апр.\": 4,\n    авг: 8,\n    \"авг.\": 8,\n    сен: 9,\n    \"сен.\": 9,\n    окт: 10,\n    \"окт.\": 10,\n    ноя: 11,\n    \"ноя.\": 11,\n    дек: 12,\n    \"дек.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    один: 1,\n    одна: 1,\n    одной: 1,\n    одну: 1,\n    две: 2,\n    два: 2,\n    двух: 2,\n    три: 3,\n    трех: 3,\n    трёх: 3,\n    четыре: 4,\n    четырех: 4,\n    четырёх: 4,\n    пять: 5,\n    пяти: 5,\n    шесть: 6,\n    шести: 6,\n    семь: 7,\n    семи: 7,\n    восемь: 8,\n    восьми: 8,\n    девять: 9,\n    девяти: 9,\n    десять: 10,\n    десяти: 10,\n    одиннадцать: 11,\n    одиннадцати: 11,\n    двенадцать: 12,\n    двенадцати: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    первое: 1,\n    первого: 1,\n    второе: 2,\n    второго: 2,\n    третье: 3,\n    третьего: 3,\n    четвертое: 4,\n    четвертого: 4,\n    пятое: 5,\n    пятого: 5,\n    шестое: 6,\n    шестого: 6,\n    седьмое: 7,\n    седьмого: 7,\n    восьмое: 8,\n    восьмого: 8,\n    девятое: 9,\n    девятого: 9,\n    десятое: 10,\n    десятого: 10,\n    одиннадцатое: 11,\n    одиннадцатого: 11,\n    двенадцатое: 12,\n    двенадцатого: 12,\n    тринадцатое: 13,\n    тринадцатого: 13,\n    четырнадцатое: 14,\n    четырнадцатого: 14,\n    пятнадцатое: 15,\n    пятнадцатого: 15,\n    шестнадцатое: 16,\n    шестнадцатого: 16,\n    семнадцатое: 17,\n    семнадцатого: 17,\n    восемнадцатое: 18,\n    восемнадцатого: 18,\n    девятнадцатое: 19,\n    девятнадцатого: 19,\n    двадцатое: 20,\n    двадцатого: 20,\n    \"двадцать первое\": 21,\n    \"двадцать первого\": 21,\n    \"двадцать второе\": 22,\n    \"двадцать второго\": 22,\n    \"двадцать третье\": 23,\n    \"двадцать третьего\": 23,\n    \"двадцать четвертое\": 24,\n    \"двадцать четвертого\": 24,\n    \"двадцать пятое\": 25,\n    \"двадцать пятого\": 25,\n    \"двадцать шестое\": 26,\n    \"двадцать шестого\": 26,\n    \"двадцать седьмое\": 27,\n    \"двадцать седьмого\": 27,\n    \"двадцать восьмое\": 28,\n    \"двадцать восьмого\": 28,\n    \"двадцать девятое\": 29,\n    \"двадцать девятого\": 29,\n    \"тридцатое\": 30,\n    \"тридцатого\": 30,\n    \"тридцать первое\": 31,\n    \"тридцать первого\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    сек: \"second\",\n    секунда: \"second\",\n    секунд: \"second\",\n    секунды: \"second\",\n    секунду: \"second\",\n    секундочка: \"second\",\n    секундочки: \"second\",\n    секундочек: \"second\",\n    секундочку: \"second\",\n    мин: \"minute\",\n    минута: \"minute\",\n    минут: \"minute\",\n    минуты: \"minute\",\n    минуту: \"minute\",\n    минуток: \"minute\",\n    минутки: \"minute\",\n    минутку: \"minute\",\n    минуточек: \"minute\",\n    минуточки: \"minute\",\n    минуточку: \"minute\",\n    час: \"hour\",\n    часов: \"hour\",\n    часа: \"hour\",\n    часу: \"hour\",\n    часиков: \"hour\",\n    часика: \"hour\",\n    часике: \"hour\",\n    часик: \"hour\",\n    день: \"d\",\n    дня: \"d\",\n    дней: \"d\",\n    суток: \"d\",\n    сутки: \"d\",\n    неделя: \"week\",\n    неделе: \"week\",\n    недели: \"week\",\n    неделю: \"week\",\n    недель: \"week\",\n    недельке: \"week\",\n    недельки: \"week\",\n    неделек: \"week\",\n    месяц: \"month\",\n    месяце: \"month\",\n    месяцев: \"month\",\n    месяца: \"month\",\n    квартал: \"quarter\",\n    квартале: \"quarter\",\n    кварталов: \"quarter\",\n    год: \"year\",\n    года: \"year\",\n    году: \"year\",\n    годов: \"year\",\n    лет: \"year\",\n    годик: \"year\",\n    годика: \"year\",\n    годиков: \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|пол|несколько|пар(?:ы|у)|\\\\s{0,3})`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    }\n    if (num.match(/несколько/)) {\n        return 3;\n    } else if (num.match(/пол/)) {\n        return 0.5;\n    } else if (num.match(/пар/)) {\n        return 2;\n    } else if (num === \"\") {\n        return 1;\n    }\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:го|ого|е|ое)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n    return parseInt(num);\n}\n\n//-----------------------------\n\nconst year = \"(?:\\\\s+(?:году|года|год|г|г.))?\";\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\\\s*(?:н.э.|до н.э.|н. э.|до н. э.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;\nexport function parseYear(match: string): number {\n    if (/(год|года|г|г.)/i.test(match)) {\n        match = match.replace(/(год|года|г|г.)/i, \"\");\n    }\n\n    if (/(до н.э.|до н. э.)/i.test(match)) {\n        //Before Common Era\n        match = match.replace(/(до н.э.|до н. э.)/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(н. э.|н.э.)/i.test(match)) {\n        //Common Era\n        match = match.replace(/(н. э.|н.э.)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:около|примерно)\\\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseTimeUnits(timeunitText): TimeUnits {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = `(?:(?:около|примерно)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})${REGEX_PARTS.rightBoundary}`;\n\nexport default class RUTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return context.option.forwardDate\n            ? new RegExp(PATTERN, REGEX_PARTS.flags)\n            : new RegExp(`(?:в течение|в течении)\\\\s*${PATTERN}`, REGEX_PARTS.flags);\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseTimeUnits(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport abstract class AbstractParserWithLeftBoundaryChecking extends AbstractParserWithWordBoundaryChecking {\n    abstract innerPatternString(context: ParsingContext): string;\n\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);\n    }\n\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return false;\n    }\n}\n\nexport abstract class AbstractParserWithLeftRightBoundaryChecking extends AbstractParserWithLeftBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class RUMonthNameLittleEndianParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        // prettier-ignore\n        return `(?:с)?\\\\s*(${ORDINAL_NUMBER_PATTERN})` +\n            `(?:` +\n                `\\\\s{0,3}(?:по|-|–|до)?\\\\s{0,3}` +\n                `(${ORDINAL_NUMBER_PATTERN})` +\n            `)?` +\n                `(?:-|\\\\/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n                `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `(?:` +\n                `(?:-|\\\\/|,?\\\\s{0,3})` +\n                `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n            `)?`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - Январь, 2012\n * - Январь 2012\n * - Январь\n */\nexport default class RUMonthNameParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `((?:в)\\\\s*)?` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `\\\\s*` +\n            `(?:` +\n            `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n            `)?` +\n            `(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"янв\", \"фер\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match.index + match[0].length);\n        result.start.imply(\"day\", 1);\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { REGEX_PARTS } from \"../constants\";\n\nexport default class RUTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    patternFlags(): string {\n        return REGEX_PARTS.flags;\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|(?:[^\\\\p{L}\\\\p{N}_]))`;\n    }\n\n    followingPhase(): string {\n        return `\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|до|и|по|\\\\?)\\\\s*`;\n    }\n\n    primaryPrefix(): string {\n        return `(?:(?:в|с)\\\\s*)??`;\n    }\n\n    primarySuffix(): string {\n        return `(?:\\\\s*(?:утра|вечера|после полудня))?(?!\\\\/)${REGEX_PARTS.rightBoundary}`;\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (components) {\n            if (match[0].endsWith(\"вечера\")) {\n                const hour = components.get(\"hour\");\n                if (hour >= 6 && hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                } else if (hour < 6) {\n                    components.assign(\"meridiem\", Meridiem.AM);\n                }\n            }\n\n            if (match[0].endsWith(\"после полудня\")) {\n                components.assign(\"meridiem\", Meridiem.PM);\n                const hour = components.get(\"hour\");\n                if (hour >= 0 && hour <= 6) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                }\n            }\n\n            if (match[0].endsWith(\"утра\")) {\n                components.assign(\"meridiem\", Meridiem.AM);\n                const hour = components.get(\"hour\");\n                if (hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\"));\n                }\n            }\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class RUTimeUnitAgoFormatParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(${TIME_UNITS_PATTERN})\\\\s{0,5}назад(?=(?:\\\\W|$))`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[1]);\n        const outputTimeUnits = reverseTimeUnits(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Russian connecting phases\n * - c 06.09.1989 [до|по] 11.12.1996\n * - c пятницы и до среды\n */\nexport default class RUMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(и до|и по|до|по|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide Russian connecting phases\n * - 2020-02-13 [в] 6:00\n * - Завтра [,] 7:00\n */\nexport default class RUMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(`^\\\\s*(T|в|,|-)?\\\\s*$`);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport * as references from \"../../../common/casualReferences\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class RUCasualDateParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(?:с|со)?\\\\s*(сегодня|вчера|завтра|послезавтра|послепослезавтра|позапозавчера|позавчера)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[1].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"сегодня\":\n                return references.today(context.reference);\n\n            case \"вчера\":\n                return references.yesterday(context.reference);\n\n            case \"завтра\":\n                return references.tomorrow(context.reference);\n\n            case \"послезавтра\":\n                return references.theDayAfter(context.reference, 2);\n\n            case \"послепослезавтра\":\n                return references.theDayAfter(context.reference, 3);\n\n            case \"позавчера\":\n                return references.theDayBefore(context.reference, 2);\n\n            case \"позапозавчера\":\n                return references.theDayBefore(context.reference, 3);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport * as references from \"../../../common/casualReferences\";\nimport { assignSimilarDate } from \"../../../utils/dayjs\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class RUCasualTimeParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(сейчас|прошлым\\\\s*вечером|прошлой\\\\s*ночью|следующей\\\\s*ночью|сегодня\\\\s*ночью|этой\\\\s*ночью|ночью|этим утром|утром|утра|в\\\\s*полдень|вечером|вечера|в\\\\s*полночь)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let targetDate = dayjs(context.refDate);\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        if (lowerText === \"сейчас\") {\n            return references.now(context.reference);\n        }\n        if (lowerText === \"вечером\" || lowerText === \"вечера\") {\n            return references.evening(context.reference);\n        }\n        if (lowerText.endsWith(\"утром\") || lowerText.endsWith(\"утра\")) {\n            return references.morning(context.reference);\n        }\n        if (lowerText.match(/в\\s*полдень/)) {\n            return references.noon(context.reference);\n        }\n        if (lowerText.match(/прошлой\\s*ночью/)) {\n            return references.lastNight(context.reference);\n        }\n        if (lowerText.match(/прошлым\\s*вечером/)) {\n            return references.yesterdayEvening(context.reference);\n        }\n        if (lowerText.match(/следующей\\s*ночью/)) {\n            const daysToAdd = targetDate.hour() < 22 ? 1 : 2;\n            targetDate = targetDate.add(daysToAdd, \"day\");\n            assignSimilarDate(component, targetDate);\n            component.imply(\"hour\", 0);\n        }\n        if (lowerText.match(/в\\s*полночь/) || lowerText.endsWith(\"ночью\")) {\n            return references.midnight(context.reference);\n        }\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class RUWeekdayParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:(?:,|\\\\(|（)\\\\s*)?` +\n            `(?:в\\\\s*?)?` +\n            `(?:(эту|этот|прошлый|прошлую|следующий|следующую|следующего)\\\\s*)?` +\n            `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n            `(?:\\\\s*(?:,|\\\\)|）))?` +\n            `(?:\\\\s*на\\\\s*(этой|прошлой|следующей)\\\\s*неделе)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"прошлый\" || modifierWord == \"прошлую\" || modifierWord == \"прошлой\") {\n            modifier = \"last\";\n        } else if (\n            modifierWord == \"следующий\" ||\n            modifierWord == \"следующую\" ||\n            modifierWord == \"следующей\" ||\n            modifierWord == \"следующего\"\n        ) {\n            modifier = \"next\";\n        } else if (modifierWord == \"этот\" || modifierWord == \"эту\" || modifierWord == \"этой\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { REGEX_PARTS, TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class RURelativeDateFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(в прошлом|на прошлой|на следующей|в следующем|на этой|в этом)\\\\s*(${matchAnyPattern(\n            TIME_UNIT_DICTIONARY\n        )})`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"на следующей\" || modifier == \"в следующем\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"в прошлом\" || modifier == \"на прошлой\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = dayjs(context.reference.instant);\n\n        // This week\n        if (timeunit.match(/week/i)) {\n            date = date.add(-date.get(\"d\"), \"d\");\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.imply(\"year\", date.year());\n        }\n\n        // This month\n        else if (timeunit.match(/month/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            components.imply(\"day\", date.date());\n            components.assign(\"year\", date.year());\n            components.assign(\"month\", date.month() + 1);\n        }\n\n        // This year\n        else if (timeunit.match(/year/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            date = date.add(-date.month(), \"month\");\n\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.assign(\"year\", date.year());\n        }\n\n        return components;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class RUTimeUnitCasualRelativeFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(эти|последние|прошлые|следующие|после|спустя|через|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[1].toLowerCase();\n        let timeUnits = parseTimeUnits(match[2]);\n        switch (prefix) {\n            case \"последние\":\n            case \"прошлые\":\n            case \"-\":\n                timeUnits = reverseTimeUnits(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Spanish support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ESWeekdayParser from \"./parsers/ESWeekdayParser\";\nimport ESTimeExpressionParser from \"./parsers/ESTimeExpressionParser\";\nimport ESMergeDateTimeRefiner from \"./refiners/ESMergeDateTimeRefiner\";\nimport ESMergeDateRangeRefiner from \"./refiners/ESMergeDateRangeRefiner\";\nimport ESMonthNameLittleEndianParser from \"./parsers/ESMonthNameLittleEndianParser\";\nimport ESCasualDateParser from \"./parsers/ESCasualDateParser\";\nimport ESCasualTimeParser from \"./parsers/ESCasualTimeParser\";\nimport ESTimeUnitWithinFormatParser from \"./parsers/ESTimeUnitWithinFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.push(new ESCasualDateParser());\n    option.parsers.push(new ESCasualTimeParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new ESWeekdayParser(),\n                new ESTimeExpressionParser(),\n                new ESMonthNameLittleEndianParser(),\n                new ESTimeUnitWithinFormatParser(),\n            ],\n            refiners: [new ESMergeDateTimeRefiner(), new ESMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"domingo\": 0,\n    \"dom\": 0,\n    \"lunes\": 1,\n    \"lun\": 1,\n    \"martes\": 2,\n    \"mar\": 2,\n    \"miércoles\": 3,\n    \"miercoles\": 3,\n    \"mié\": 3,\n    \"mie\": 3,\n    \"jueves\": 4,\n    \"jue\": 4,\n    \"viernes\": 5,\n    \"vie\": 5,\n    \"sábado\": 6,\n    \"sabado\": 6,\n    \"sáb\": 6,\n    \"sab\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"enero\": 1,\n    \"ene\": 1,\n    \"ene.\": 1,\n    \"febrero\": 2,\n    \"feb\": 2,\n    \"feb.\": 2,\n    \"marzo\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"abril\": 4,\n    \"abr\": 4,\n    \"abr.\": 4,\n    \"mayo\": 5,\n    \"may\": 5,\n    \"may.\": 5,\n    \"junio\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"julio\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"agosto\": 8,\n    \"ago\": 8,\n    \"ago.\": 8,\n    \"septiembre\": 9,\n    \"setiembre\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"octubre\": 10,\n    \"oct\": 10,\n    \"oct.\": 10,\n    \"noviembre\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"diciembre\": 12,\n    \"dic\": 12,\n    \"dic.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"uno\": 1,\n    \"dos\": 2,\n    \"tres\": 3,\n    \"cuatro\": 4,\n    \"cinco\": 5,\n    \"seis\": 6,\n    \"siete\": 7,\n    \"ocho\": 8,\n    \"nueve\": 9,\n    \"diez\": 10,\n    \"once\": 11,\n    \"doce\": 12,\n    \"trece\": 13,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    \"sec\": \"second\",\n    \"segundo\": \"second\",\n    \"segundos\": \"second\",\n    \"min\": \"minute\",\n    \"mins\": \"minute\",\n    \"minuto\": \"minute\",\n    \"minutos\": \"minute\",\n    \"h\": \"hour\",\n    \"hr\": \"hour\",\n    \"hrs\": \"hour\",\n    \"hora\": \"hour\",\n    \"horas\": \"hour\",\n    \"día\": \"d\",\n    \"días\": \"d\",\n    \"semana\": \"week\",\n    \"semanas\": \"week\",\n    \"mes\": \"month\",\n    \"meses\": \"month\",\n    \"cuarto\": \"quarter\",\n    \"cuartos\": \"quarter\",\n    \"año\": \"year\",\n    \"años\": \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|un?|uno?|una?|algunos?|unos?|demi-?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"un\" || num === \"una\" || num === \"uno\") {\n        return 1;\n    } else if (num.match(/algunos?/)) {\n        return 3;\n    } else if (num.match(/unos?/)) {\n        return 3;\n    } else if (num.match(/media?/)) {\n        return 0.5;\n    }\n\n    return parseFloat(num);\n}\n//-----------------------------\n// 88 p. Chr. n.\n// 234 AC\nexport const YEAR_PATTERN = \"[0-9]{1,4}(?![^\\\\s]\\\\d)(?:\\\\s*[a|d]\\\\.?\\\\s*c\\\\.?|\\\\s*a\\\\.?\\\\s*d\\\\.?)?\";\nexport function parseYear(match: string): number {\n    if (match.match(/^[0-9]{1,4}$/)) {\n        let yearNumber = parseInt(match);\n        if (yearNumber < 100) {\n            if (yearNumber > 50) {\n                yearNumber = yearNumber + 1900;\n            } else {\n                yearNumber = yearNumber + 2000;\n            }\n        }\n        return yearNumber;\n    }\n\n    if (match.match(/a\\.?\\s*c\\.?/i)) {\n        match = match.replace(/a\\.?\\s*c\\.?/i, \"\");\n        return -parseInt(match);\n    }\n\n    return parseInt(match);\n}\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseTimeUnits(timeunitText): { [c in OpUnitType | QUnitType]?: number } {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as { [c in OpUnitType | QUnitType]?: number };\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:(este|esta|pasado|pr[oó]ximo)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(este|esta|pasado|pr[óo]ximo)\\\\s*semana)?\" +\n        \"(?=\\\\W|\\\\d|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ESWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        if (weekday === undefined) {\n            return null;\n        }\n\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let norm = prefix || postfix || \"\";\n        norm = norm.toLowerCase();\n\n        let modifier = null;\n        if (norm == \"pasado\") {\n            modifier = \"this\";\n        } else if (norm == \"próximo\" || norm == \"proximo\") {\n            modifier = \"next\";\n        } else if (norm == \"este\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class ESTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:aslas|deslas|las?|al?|de|del)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|a(?:l)?|\\\\?)\\\\s*\";\n    }\n\n    // extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n    //     // This looks more like a year e.g. 2020\n    //     // if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n    //     //     return null;\n    //     // }\n    //\n    //     return super.extractPrimaryTimeComponents(context, match);\n    // }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class ESMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(?:,|de|aslas|a)?\\\\s*$\");\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class ESMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(?:-)\\s*$/i;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `([0-9]{1,2})(?:º|ª|°)?` +\n        \"(?:\\\\s*(?:desde|de|\\\\-|\\\\–|ao?|\\\\s)\\\\s*([0-9]{1,2})(?:º|ª|°)?)?\\\\s*(?:de)?\\\\s*\" +\n        `(?:-|/|\\\\s*(?:de|,)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:\\\\s*(?:de|,)?\\\\s*(${YEAR_PATTERN}))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ESMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class ESCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(ahora|hoy|mañana|ayer)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"ahora\":\n                return references.now(context.reference);\n\n            case \"hoy\":\n                return references.today(context.reference);\n\n            case \"mañana\":\n                return references.tomorrow(context.reference);\n\n            case \"ayer\":\n                return references.yesterday(context.reference);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignTheNextDay } from \"../../../utils/dayjs\";\nimport dayjs from \"dayjs\";\n\nexport default class ESCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return /(?:esta\\s*)?(mañana|tarde|medianoche|mediodia|mediodía|noche)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = dayjs(context.refDate);\n        const component = context.createParsingComponents();\n        switch (match[1].toLowerCase()) {\n            case \"tarde\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"noche\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 22);\n                break;\n\n            case \"mañana\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"medianoche\":\n                assignTheNextDay(component, targetDate);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"mediodia\":\n            case \"mediodía\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class ESTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:en|por|durante|de|dentro de)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseTimeUnits(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Ukrainian support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport UKTimeUnitWithinFormatParser from \"./parsers/UKTimeUnitWithinFormatParser\";\nimport UKMonthNameLittleEndianParser from \"./parsers/UKMonthNameLittleEndianParser\";\nimport UkMonthNameParser from \"./parsers/UKMonthNameParser\";\nimport UKTimeExpressionParser from \"./parsers/UKTimeExpressionParser\";\nimport UKTimeUnitAgoFormatParser from \"./parsers/UKTimeUnitAgoFormatParser\";\nimport UKMergeDateRangeRefiner from \"./refiners/UKMergeDateRangeRefiner\";\nimport UKMergeDateTimeRefiner from \"./refiners/UKMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport UKCasualDateParser from \"./parsers/UKCasualDateParser\";\nimport UKCasualTimeParser from \"./parsers/UKCasualTimeParser\";\nimport UKWeekdayParser from \"./parsers/UKWeekdayParser\";\nimport UKRelativeDateFormatParser from \"./parsers/UKRelativeDateFormatParser\";\n\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport UKTimeUnitCasualRelativeFormatParser from \"./parsers/UKTimeUnitCasualRelativeFormatParser\";\nimport ISOFormatParser from \"../../common/parsers/ISOFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n/**\n * Chrono object configured for parsing *casual* Ukrainian\n */\nexport const casual = new Chrono(createCasualConfiguration());\n\n/**\n * Chrono object configured for parsing *strict* Ukrainian\n */\nexport const strict = new Chrono(createConfiguration(true));\n\n/**\n * Create a default *casual* {@Link Configuration} for Ukrainian chrono.\n * It calls {@Link createConfiguration} and includes additional parsers.\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration(false);\n    option.parsers.unshift(new UKCasualDateParser());\n    option.parsers.unshift(new UKCasualTimeParser());\n    option.parsers.unshift(new UkMonthNameParser());\n    option.parsers.unshift(new UKRelativeDateFormatParser());\n    option.parsers.unshift(new UKTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * Create a default {@Link Configuration} for Ukrainian chrono\n *\n * @param strictMode If the timeunit mentioning should be strict, not casual\n */\nexport function createConfiguration(strictMode: boolean): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new ISOFormatParser(),\n                new SlashDateFormatParser(true),\n                new UKTimeUnitWithinFormatParser(),\n                new UKMonthNameLittleEndianParser(),\n                new UKWeekdayParser(),\n                new UKTimeExpressionParser(strictMode),\n                new UKTimeUnitAgoFormatParser(),\n            ],\n            refiners: [new UKMergeDateTimeRefiner(), new UKMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n\n/**\n * A shortcut for uk.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for uk.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n", "import { OpUnitType, QUnitType } from \"dayjs\";\nimport { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { TimeUnits } from \"../../utils/timeunits\";\n\nexport const REGEX_PARTS = {\n    leftBoundary: \"([^\\\\p{L}\\\\p{N}_]|^)\",\n    rightBoundary: \"(?=[^\\\\p{L}\\\\p{N}_]|$)\",\n    flags: \"iu\",\n};\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"неділя\": 0,\n    \"неділі\": 0,\n    \"неділю\": 0,\n    \"нд\": 0,\n    \"нд.\": 0,\n    \"понеділок\": 1,\n    \"понеділка\": 1,\n    \"пн\": 1,\n    \"пн.\": 1,\n    \"вівторок\": 2,\n    \"вівторка\": 2,\n    \"вт\": 2,\n    \"вт.\": 2,\n    \"середа\": 3,\n    \"середи\": 3,\n    \"середу\": 3,\n    \"ср\": 3,\n    \"ср.\": 3,\n    \"четвер\": 4,\n    \"четверга\": 4,\n    \"четвергу\": 4,\n    \"чт\": 4,\n    \"чт.\": 4,\n    \"п'ятниця\": 5,\n    \"п'ятниці\": 5,\n    \"п'ятницю\": 5,\n    \"пт\": 5,\n    \"пт.\": 5,\n    \"субота\": 6,\n    \"суботи\": 6,\n    \"суботу\": 6,\n    \"сб\": 6,\n    \"сб.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    \"січень\": 1,\n    \"січня\": 1,\n    \"січні\": 1,\n    \"лютий\": 2,\n    \"лютого\": 2,\n    \"лютому\": 2,\n    \"березень\": 3,\n    \"березня\": 3,\n    \"березні\": 3,\n    \"квітень\": 4,\n    \"квітня\": 4,\n    \"квітні\": 4,\n    \"травень\": 5,\n    \"травня\": 5,\n    \"травні\": 5,\n    \"червень\": 6,\n    \"червня\": 6,\n    \"червні\": 6,\n    \"липень\": 7,\n    \"липня\": 7,\n    \"липні\": 7,\n    \"серпень\": 8,\n    \"серпня\": 8,\n    \"серпні\": 8,\n    \"вересень\": 9,\n    \"вересня\": 9,\n    \"вересні\": 9,\n    \"жовтень\": 10,\n    \"жовтня\": 10,\n    \"жовтні\": 10,\n    \"листопад\": 11,\n    \"листопада\": 11,\n    \"листопаду\": 11,\n    \"грудень\": 12,\n    \"грудня\": 12,\n    \"грудні\": 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    \"січ\": 1,\n    \"січ.\": 1,\n    \"лют\": 2,\n    \"лют.\": 2,\n    \"бер\": 3,\n    \"бер.\": 3,\n    \"квіт\": 4,\n    \"квіт.\": 4,\n    \"трав\": 5,\n    \"трав.\": 5,\n    \"черв\": 6,\n    \"черв.\": 6,\n    \"лип\": 7,\n    \"лип.\": 7,\n    \"серп\": 8,\n    \"серп.\": 8,\n    \"сер\": 8,\n    \"cер.\": 8,\n    \"вер\": 9,\n    \"вер.\": 9,\n    \"верес\": 9,\n    \"верес.\": 9,\n    \"жовт\": 10,\n    \"жовт.\": 10,\n    \"листоп\": 11,\n    \"листоп.\": 11,\n    \"груд\": 12,\n    \"груд.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"один\": 1,\n    \"одна\": 1,\n    \"одної\": 1,\n    \"одну\": 1,\n    \"дві\": 2,\n    \"два\": 2,\n    \"двох\": 2,\n    \"три\": 3,\n    \"трьох\": 3,\n    \"чотири\": 4,\n    \"чотирьох\": 4,\n    \"п'ять\": 5,\n    \"п'яти\": 5,\n    \"шість\": 6,\n    \"шести\": 6,\n    \"сім\": 7,\n    \"семи\": 7,\n    \"вісім\": 8,\n    \"восьми\": 8,\n    \"дев'ять\": 9,\n    \"дев'яти\": 9,\n    \"десять\": 10,\n    \"десяти\": 10,\n    \"одинадцять\": 11,\n    \"одинадцяти\": 11,\n    \"дванадцять\": 12,\n    \"дванадцяти\": 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    \"перше\": 1,\n    \"першого\": 1,\n    \"друге\": 2,\n    \"другого\": 2,\n    \"третє\": 3,\n    \"третього\": 3,\n    \"четверте\": 4,\n    \"четвертого\": 4,\n    \"п'яте\": 5,\n    \"п'ятого\": 5,\n    \"шосте\": 6,\n    \"шостого\": 6,\n    \"сьоме\": 7,\n    \"сьомого\": 7,\n    \"восьме\": 8,\n    \"восьмого\": 8,\n    \"дев'яте\": 9,\n    \"дев'ятого\": 9,\n    \"десяте\": 10,\n    \"десятого\": 10,\n    \"одинадцяте\": 11,\n    \"одинадцятого\": 11,\n    \"дванадцяте\": 12,\n    \"дванадцятого\": 12,\n    \"тринадцяте\": 13,\n    \"тринадцятого\": 13,\n    \"чотирнадцяте\": 14,\n    \"чотинрнадцятого\": 14,\n    \"п'ятнадцяте\": 15,\n    \"п'ятнадцятого\": 15,\n    \"шістнадцяте\": 16,\n    \"шістнадцятого\": 16,\n    \"сімнадцяте\": 17,\n    \"сімнадцятого\": 17,\n    \"вісімнадцяте\": 18,\n    \"вісімнадцятого\": 18,\n    \"дев'ятнадцяте\": 19,\n    \"дев'ятнадцятого\": 19,\n    \"двадцяте\": 20,\n    \"двадцятого\": 20,\n    \"двадцять перше\": 21,\n    \"двадцять першого\": 21,\n    \"двадцять друге\": 22,\n    \"двадцять другого\": 22,\n    \"двадцять третє\": 23,\n    \"двадцять третього\": 23,\n    \"двадцять четверте\": 24,\n    \"двадцять четвертого\": 24,\n    \"двадцять п'яте\": 25,\n    \"двадцять п'ятого\": 25,\n    \"двадцять шосте\": 26,\n    \"двадцять шостого\": 26,\n    \"двадцять сьоме\": 27,\n    \"двадцять сьомого\": 27,\n    \"двадцять восьме\": 28,\n    \"двадцять восьмого\": 28,\n    \"двадцять дев'яте\": 29,\n    \"двадцять дев'ятого\": 29,\n    \"тридцяте\": 30,\n    \"тридцятого\": 30,\n    \"тридцять перше\": 31,\n    \"тридцять першого\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: OpUnitType | QUnitType } = {\n    сек: \"second\",\n    секунда: \"second\",\n    секунд: \"second\",\n    секунди: \"second\",\n    секунду: \"second\",\n    секундочок: \"second\",\n    секундочки: \"second\",\n    секундочку: \"second\",\n    хв: \"minute\",\n    хвилина: \"minute\",\n    хвилин: \"minute\",\n    хвилини: \"minute\",\n    хвилину: \"minute\",\n    хвилинок: \"minute\",\n    хвилинки: \"minute\",\n    хвилинку: \"minute\",\n    хвилиночок: \"minute\",\n    хвилиночки: \"minute\",\n    хвилиночку: \"minute\",\n    год: \"hour\",\n    година: \"hour\",\n    годин: \"hour\",\n    години: \"hour\",\n    годину: \"hour\",\n    годинка: \"hour\",\n    годинок: \"hour\",\n    годинки: \"hour\",\n    годинку: \"hour\",\n    день: \"d\",\n    дня: \"d\",\n    днів: \"d\",\n    дні: \"d\",\n    доба: \"d\",\n    добу: \"d\",\n    тиждень: \"week\",\n    тижню: \"week\",\n    тижня: \"week\",\n    тижні: \"week\",\n    тижнів: \"week\",\n    місяць: \"month\",\n    місяців: \"month\",\n    місяці: \"month\",\n    місяця: \"month\",\n    квартал: \"quarter\",\n    кварталу: \"quarter\",\n    квартала: \"quarter\",\n    кварталів: \"quarter\",\n    кварталі: \"quarter\",\n    рік: \"year\",\n    року: \"year\",\n    році: \"year\",\n    років: \"year\",\n    роки: \"year\",\n};\n\n//--------------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|пів|декілька|пар(?:у)|\\\\s{0,3})`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    }\n    if (num.match(/декілька/)) {\n        return 2;\n    } else if (num.match(/пів/)) {\n        return 0.5;\n    } else if (num.match(/пар/)) {\n        return 2;\n    } else if (num === \"\") {\n        return 1;\n    }\n    return parseFloat(num);\n}\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:го|ого|е)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n    return parseInt(num);\n}\n\nconst year = \"(?:\\\\s+(?:року|рік|р|р.))?\";\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\\\s*(?:н.е.|до н.е.|н. е.|до н. е.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;\nexport function parseYearPattern(match: string): number {\n    if (/(рік|року|р|р.)/i.test(match)) {\n        match = match.replace(/(рік|року|р|р.)/i, \"\");\n    }\n\n    if (/(до н.е.|до н. е.)/i.test(match)) {\n        //Before Common Era\n        match = match.replace(/(до н.е.|до н. е.)/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(н. е.|н.е.)/i.test(match)) {\n        //Common Era\n        match = match.replace(/(н. е.|н.е.)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:близько|приблизно)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_PATTERN\n);\n\nexport function parseTimeUnits(timeunitText): TimeUnits {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = `(?:(?:приблизно|орієнтовно)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})${REGEX_PARTS.rightBoundary}`;\n\nexport default class UKTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return context.option.forwardDate\n            ? new RegExp(PATTERN, \"i\")\n            : new RegExp(`(?:протягом|на протязі|протягом|упродовж|впродовж)\\\\s*${PATTERN}`, REGEX_PARTS.flags);\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseTimeUnits(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "// noinspection DuplicatedCode\n\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport abstract class AbstractParserWithLeftBoundaryChecking extends AbstractParserWithWordBoundaryChecking {\n    abstract innerPatternString(context: ParsingContext): string;\n\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);\n    }\n\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return false;\n    }\n}\n\nexport abstract class AbstractParserWithLeftRightBoundaryChecking extends AbstractParserWithLeftBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYearPattern } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class UKMonthNameLittleEndianParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:з|із)?\\\\s*(${ORDINAL_NUMBER_PATTERN})` +\n            `(?:` +\n            `\\\\s{0,3}(?:по|-|–|до)?\\\\s{0,3}` +\n            `(${ORDINAL_NUMBER_PATTERN})` +\n            `)?` +\n            `(?:-|\\\\/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `(?:` +\n            `(?:-|\\\\/|,?\\\\s{0,3})` +\n            `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n            `)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYearPattern(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.reference.instant, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYearPattern } from \"../constants\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - Cічень, 2012\n * - Січень 2012\n * - Січень\n */\nexport default class UkMonthNameParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `((?:в|у)\\\\s*)?` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `\\\\s*` +\n            `(?:` +\n            `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n            `)?` +\n            `(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"січ\", \"лют\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match.index + match[0].length);\n        result.start.imply(\"day\", 1);\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYearPattern(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.reference.instant, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { REGEX_PARTS } from \"../constants\";\n\nexport default class UKTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    patternFlags(): string {\n        return REGEX_PARTS.flags;\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|(?:[^\\\\p{L}\\\\p{N}_]))`;\n    }\n\n    followingPhase(): string {\n        return `\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|до|і|по|\\\\?)\\\\s*`;\n    }\n\n    primaryPrefix(): string {\n        return `(?:(?:в|у|о|об|з|із|від)\\\\s*)??`;\n    }\n\n    primarySuffix(): string {\n        return `(?:\\\\s*(?:ранку|вечора|по обіді|після обіду))?(?!\\\\/)${REGEX_PARTS.rightBoundary}`;\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (components) {\n            if (match[0].endsWith(\"вечора\")) {\n                const hour = components.get(\"hour\");\n                if (hour >= 6 && hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                } else if (hour < 6) {\n                    components.assign(\"meridiem\", Meridiem.AM);\n                }\n            }\n\n            if (match[0].endsWith(\"по обіді\") || match[0].endsWith(\"після обіду\")) {\n                components.assign(\"meridiem\", Meridiem.PM);\n                const hour = components.get(\"hour\");\n                if (hour >= 0 && hour <= 6) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                }\n            }\n\n            if (match[0].endsWith(\"ранку\")) {\n                components.assign(\"meridiem\", Meridiem.AM);\n                const hour = components.get(\"hour\");\n                if (hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\"));\n                }\n            }\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseTimeUnits, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class UKTimeUnitAgoFormatParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(${TIME_UNITS_PATTERN})\\\\s{0,5}тому(?=(?:\\\\W|$))`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseTimeUnits(match[1]);\n        const outputTimeUnits = reverseTimeUnits(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Russian connecting phases\n * - [з|із] 06.09.1989 [до|по] 11.12.1996\n * - [з|із] п'ятниці і до середи\n */\nexport default class UKMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(і до|і по|до|по|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide Ukrainian connecting phases\n * - 2020-02-13 [в/у/о] 6:00\n * - Завтра [,] 7:00\n */\nexport default class UKMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(`^\\\\s*(T|в|у|о|,|-)?\\\\s*$`);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport * as references from \"../../../common/casualReferences\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class UKCasualDateParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(?:з|із|від)?\\\\s*(сьогодні|вчора|завтра|післязавтра|післяпіслязавтра|позапозавчора|позавчора)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[1].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"сьогодні\":\n                return references.today(context.reference);\n\n            case \"вчора\":\n                return references.yesterday(context.reference);\n\n            case \"завтра\":\n                return references.tomorrow(context.reference);\n\n            case \"післязавтра\":\n                return references.theDayAfter(context.reference, 2);\n\n            case \"післяпіслязавтра\":\n                return references.theDayAfter(context.reference, 3);\n\n            case \"позавчора\":\n                return references.theDayBefore(context.reference, 2);\n\n            case \"позапозавчора\":\n                return references.theDayBefore(context.reference, 3);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport * as references from \"../../../common/casualReferences\";\nimport { assignSimilarDate } from \"../../../utils/dayjs\";\nimport dayjs from \"dayjs\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class UKCasualTimeParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(зараз|минулого\\\\s*вечора|минулої\\\\s*ночі|наступної\\\\s*ночі|сьогодні\\\\s*вночі|цієї\\\\s*ночі|цього ранку|вранці|ранку|зранку|опівдні|ввечері|вечора|опівночі|вночі)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let targetDate = dayjs(context.reference.instant);\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        if (lowerText === \"зараз\") {\n            return references.now(context.reference);\n        }\n        if (lowerText === \"ввечері\" || lowerText === \"вечора\") {\n            return references.evening(context.reference);\n        }\n        if (lowerText.endsWith(\"вранці\") || lowerText.endsWith(\"ранку\") || lowerText.endsWith(\"зранку\")) {\n            return references.morning(context.reference);\n        }\n        if (lowerText.endsWith(\"опівдні\")) {\n            return references.noon(context.reference);\n        }\n        if (lowerText.match(/минулої\\s*ночі/)) {\n            return references.lastNight(context.reference);\n        }\n        if (lowerText.match(/минулого\\s*вечора/)) {\n            return references.yesterdayEvening(context.reference);\n        }\n        if (lowerText.match(/наступної\\s*ночі/)) {\n            const daysToAdd = targetDate.hour() < 22 ? 1 : 2;\n            targetDate = targetDate.add(daysToAdd, \"day\");\n            assignSimilarDate(component, targetDate);\n            component.imply(\"hour\", 1);\n        }\n        if (lowerText.match(/цієї\\s*ночі/)) {\n            return references.midnight(context.reference);\n        }\n        if (lowerText.endsWith(\"опівночі\") || lowerText.endsWith(\"вночі\")) {\n            return references.midnight(context.reference);\n        }\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\n// TODO: ADD REGEX_PARTS below\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { createParsingComponentsAtWeekday } from \"../../../common/calculation/weekdays\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class UKWeekdayParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:(?:,|\\\\(|（)\\\\s*)?` +\n            `(?:в\\\\s*?)?` +\n            `(?:у\\\\s*?)?` +\n            `(?:(цей|минулого|минулий|попередній|попереднього|наступного|наступний|наступному)\\\\s*)?` +\n            `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n            `(?:\\\\s*(?:,|\\\\)|）))?` +\n            `(?:\\\\s*(на|у|в)\\\\s*(цьому|минулому|наступному)\\\\s*тижні)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLocaleLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLocaleLowerCase();\n\n        let modifier = null;\n        if (\n            modifierWord == \"минулого\" ||\n            modifierWord == \"минулий\" ||\n            modifierWord == \"попередній\" ||\n            modifierWord == \"попереднього\"\n        ) {\n            modifier = \"last\";\n        } else if (modifierWord == \"наступного\" || modifierWord == \"наступний\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"цей\" || modifierWord == \"цього\" || modifierWord == \"цьому\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport dayjs from \"dayjs\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class UKRelativeDateFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(в минулому|у минулому|на минулому|минулого|на наступному|в наступному|у наступному|наступного|на цьому|в цьому|у цьому|цього)\\\\s*` +\n            `(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (\n            modifier == \"на наступному\" ||\n            modifier == \"в наступному\" ||\n            modifier == \"у наступному\" ||\n            modifier == \"наступного\"\n        ) {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (\n            modifier == \"на минулому\" ||\n            modifier == \"в минулому\" ||\n            modifier == \"у минулому\" ||\n            modifier == \"минулого\"\n        ) {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = dayjs(context.reference.instant);\n\n        // This week\n        if (timeunit.match(/week/i)) {\n            date = date.add(-date.get(\"d\"), \"d\");\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.imply(\"year\", date.year());\n        }\n\n        // This month\n        else if (timeunit.match(/month/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            components.imply(\"day\", date.date());\n            components.assign(\"year\", date.year());\n            components.assign(\"month\", date.month() + 1);\n        }\n\n        // This year\n        else if (timeunit.match(/year/i)) {\n            date = date.add(-date.date() + 1, \"d\");\n            date = date.add(-date.month(), \"month\");\n\n            components.imply(\"day\", date.date());\n            components.imply(\"month\", date.month() + 1);\n            components.assign(\"year\", date.year());\n        }\n\n        return components;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseTimeUnits, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { reverseTimeUnits } from \"../../../utils/timeunits\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class UKTimeUnitCasualRelativeFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(ці|останні|минулі|майбутні|наступні|після|через|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[1].toLowerCase();\n        let timeUnits = parseTimeUnits(match[3]);\n        switch (prefix) {\n            case \"останні\":\n            case \"минулі\":\n            case \"-\":\n                timeUnits = reverseTimeUnits(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import * as en from \"./locales/en\";\nimport { Chrono, Parser, Refiner } from \"./chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"./results\";\nimport { Component, ParsedComponents, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"./types\";\n\nexport { en, Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedComponents, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Export all locales\nimport * as de from \"./locales/de\";\nimport * as fr from \"./locales/fr\";\nimport * as ja from \"./locales/ja\";\nimport * as pt from \"./locales/pt\";\nimport * as nl from \"./locales/nl\";\nimport * as zh from \"./locales/zh\";\nimport * as ru from \"./locales/ru\";\nimport * as es from \"./locales/es\";\nimport * as uk from \"./locales/uk\";\n\nexport { de, fr, ja, pt, nl, zh, ru, es, uk };\n\n/**\n * A shortcut for {@link en | chrono.en.strict}\n */\nexport const strict = en.strict;\n\n/**\n * A shortcut for {@link en | chrono.en.casual}\n */\nexport const casual = en.casual;\n\n/**\n * A shortcut for {@link en | chrono.en.casual.parse()}\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for {@link en | chrono.en.casual.parseDate()}\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date | null {\n    return casual.parseDate(text, ref, option);\n}\n"],
  "mappings": "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",
  "names": ["t", "e", "i", "r", "s", "t", "e", "n", "r", "i", "s", "u", "a", "M", "m", "f", "l", "$", "y", "v", "g", "D", "o", "d", "c", "h", "import_dayjs", "Meridiem", "Weekday", "Month", "year", "dayjs", "dayjs", "quarterOfYear", "import_dayjs", "dayjs", "year", "PATTERN", "MONTH_NAME_GROUP", "DATE_GROUP", "DATE_TO_GROUP", "YEAR_GROUP", "year", "PATTERN", "MONTH_NAME_GROUP", "YEAR_GROUP", "year", "PATTERN", "MONTH_NAME_GROUP", "year", "PATTERN", "YEAR_GROUP", "year", "strict", "PATTERN", "PATTERN", "STRICT_PATTERN", "import_dayjs", "implySimilarDate", "dayjs", "implySimilarDate", "PATTERN", "YEAR_NUMBER_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "configuration", "import_dayjs", "import_dayjs", "dayjs", "PATTERN", "dayjs", "PATTERN", "PATTERN", "PREFIX_GROUP", "import_dayjs", "PATTERN", "dayjs", "PATTERN", "YEAR_GROUP", "year", "PATTERN", "YEAR_GROUP", "year", "configuration", "casual", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseTimeUnits", "collectDateTimeFragment", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "import_dayjs", "import_dayjs", "dayjs", "PATTERN", "DATE_GROUP", "dayjs", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "NUMBER_PATTERN", "TIME_UNIT_DICTIONARY", "parseNumberPattern", "TIME_UNITS_PATTERN", "parseTimeUnits", "casual", "strict", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "import_dayjs", "dayjs", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseTimeUnits", "collectDateTimeFragment", "PATTERN", "WEEKDAY_DICTIONARY", "WEEKDAY_GROUP", "POSTFIX_GROUP", "FIRST_REG_PATTERN", "SECOND_REG_PATTERN", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "PATTERN", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseOrdinalNumberPattern", "parseYear", "year", "TIME_UNITS_PATTERN", "parseTimeUnits", "TIME_UNITS_PATTERN", "parseTimeUnits", "FRTimeUnitAgoFormatParser", "NUMBER_PATTERN", "TIME_UNIT_DICTIONARY", "parseNumberPattern", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "FRTimeUnitAgoFormatParser", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "import_dayjs", "PATTERN", "YEAR_NUMBER_GROUP", "MONTH_GROUP", "dayjs", "year", "import_dayjs", "PATTERN", "dayjs", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "YEAR_PATTERN", "parseYear", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "import_dayjs", "dayjs", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "import_dayjs", "DAY_GROUP", "dayjs", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseTimeUnits", "collectDateTimeFragment", "TIME_UNITS_PATTERN", "parseTimeUnits", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "MONTH_NAME_GROUP", "DATE_GROUP", "DATE_TO_GROUP", "YEAR_GROUP", "parseOrdinalNumberPattern", "year", "parseYear", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "MONTH_NAME_GROUP", "YEAR_GROUP", "year", "parseYear", "PATTERN", "MONTH_GROUP", "YEAR_GROUP", "year", "PATTERN", "MONTH_DICTIONARY", "YEAR_NUMBER_GROUP", "MONTH_NAME_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "year", "import_dayjs", "DATE_GROUP", "dayjs", "PATTERN", "TIME_UNITS_PATTERN", "parseTimeUnits", "import_dayjs", "PATTERN", "TIME_UNIT_DICTIONARY", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "dayjs", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "parseTimeUnits", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "GROUP_NUM_TIMEUNITS", "parseTimeUnits", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "import_dayjs", "YEAR_GROUP", "MONTH_GROUP", "DAY_GROUP", "dayjs", "year", "import_dayjs", "PATTERN", "dayjs", "import_dayjs", "PATTERN", "dayjs", "import_dayjs", "FIRST_REG_PATTERN", "SECOND_REG_PATTERN", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "dayjs", "import_dayjs", "PATTERN", "dayjs", "import_dayjs", "DAY_GROUP_1", "DAY_GROUP_3", "dayjs", "import_dayjs", "NUMBER", "WEEKDAY_OFFSET", "zhStringToNumber", "zhStringToYear", "YEAR_GROUP", "MONTH_GROUP", "DAY_GROUP", "NUMBER", "dayjs", "zhStringToNumber", "year", "zhStringToYear", "import_dayjs", "PATTERN", "NUMBER", "NUMBER_GROUP", "UNIT_GROUP", "zhStringToNumber", "dayjs", "import_dayjs", "PATTERN", "WEEKDAY_OFFSET", "dayjs", "import_dayjs", "FIRST_REG_PATTERN", "NUMBER", "SECOND_REG_PATTERN", "DAY_GROUP_1", "ZH_AM_PM_HOUR_GROUP_1", "ZH_AM_PM_HOUR_GROUP_2", "DAY_GROUP_3", "ZH_AM_PM_HOUR_GROUP_3", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "dayjs", "zhStringToNumber", "import_dayjs", "PATTERN", "WEEKDAY_OFFSET", "dayjs", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "createCasualConfiguration", "casual", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "import_dayjs", "NOW_GROUP", "DAY_GROUP_1", "TIME_GROUP_1", "TIME_GROUP_2", "DAY_GROUP_3", "TIME_GROUP_3", "dayjs", "createCasualConfiguration", "casual", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "FULL_MONTH_NAME_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseTimeUnits", "collectDateTimeFragment", "PATTERN", "TIME_UNITS_PATTERN", "parseTimeUnits", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "parseOrdinalNumberPattern", "parseYear", "year", "MONTH_NAME_GROUP", "YEAR_GROUP", "MONTH_DICTIONARY", "YEAR_PATTERN", "FULL_MONTH_NAME_DICTIONARY", "year", "parseYear", "TIME_UNITS_PATTERN", "parseTimeUnits", "import_dayjs", "dayjs", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "WEEKDAY_DICTIONARY", "import_dayjs", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "TIME_UNIT_DICTIONARY", "dayjs", "TIME_UNITS_PATTERN", "parseTimeUnits", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseTimeUnits", "collectDateTimeFragment", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "import_dayjs", "dayjs", "TIME_UNITS_PATTERN", "parseTimeUnits", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "REGEX_PARTS", "WEEKDAY_DICTIONARY", "FULL_MONTH_NAME_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "year", "YEAR_PATTERN", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseTimeUnits", "collectDateTimeFragment", "PATTERN", "TIME_UNITS_PATTERN", "REGEX_PARTS", "parseTimeUnits", "AbstractParserWithLeftBoundaryChecking", "REGEX_PARTS", "AbstractParserWithLeftRightBoundaryChecking", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "AbstractParserWithLeftRightBoundaryChecking", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "parseOrdinalNumberPattern", "year", "MONTH_NAME_GROUP", "YEAR_GROUP", "AbstractParserWithLeftBoundaryChecking", "MONTH_DICTIONARY", "YEAR_PATTERN", "FULL_MONTH_NAME_DICTIONARY", "year", "REGEX_PARTS", "AbstractParserWithLeftBoundaryChecking", "TIME_UNITS_PATTERN", "parseTimeUnits", "AbstractParserWithLeftRightBoundaryChecking", "import_dayjs", "AbstractParserWithLeftRightBoundaryChecking", "dayjs", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "AbstractParserWithLeftRightBoundaryChecking", "WEEKDAY_DICTIONARY", "import_dayjs", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "AbstractParserWithLeftRightBoundaryChecking", "TIME_UNIT_DICTIONARY", "dayjs", "AbstractParserWithLeftRightBoundaryChecking", "TIME_UNITS_PATTERN", "parseTimeUnits", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "strict", "casual", "parse", "parseDate"]
}
